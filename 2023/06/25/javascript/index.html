<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>javascript | Lemonxu's Blog</title><meta name="author" content="Lemonxu"><meta name="copyright" content="Lemonxu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JS基础引入方式JavaScript有3种引入方式：行内式、嵌入式和外链式； 行内式：将JavaScript代码作为Html标签的属性值使用。示例如下： 1&lt;a href&#x3D;&quot;javascript:alert(&amp;#x27;hello&amp;#x27;)&quot;&gt;say hello&lt;&#x2F;a&gt;  嵌入式：或称内嵌式，使用script标签包裹JavaScript代码，直接编写">
<meta property="og:type" content="article">
<meta property="og:title" content="javascript">
<meta property="og:url" content="https://lemonxu.eu.org/2023/06/25/javascript/index.html">
<meta property="og:site_name" content="Lemonxu&#39;s Blog">
<meta property="og:description" content="JS基础引入方式JavaScript有3种引入方式：行内式、嵌入式和外链式； 行内式：将JavaScript代码作为Html标签的属性值使用。示例如下： 1&lt;a href&#x3D;&quot;javascript:alert(&amp;#x27;hello&amp;#x27;)&quot;&gt;say hello&lt;&#x2F;a&gt;  嵌入式：或称内嵌式，使用script标签包裹JavaScript代码，直接编写">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lemonxu.eu.org/images/bg/646.jpg">
<meta property="article:published_time" content="2023-06-25T17:39:57.000Z">
<meta property="article:modified_time" content="2023-09-07T01:34:26.414Z">
<meta property="article:author" content="Lemonxu">
<meta property="article:tag" content="JavaScript, 基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lemonxu.eu.org/images/bg/646.jpg"><link rel="shortcut icon" href="/images/favicon-32x32-next.png"><link rel="canonical" href="https://lemonxu.eu.org/2023/06/25/javascript/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="baidu-site-verification" content="codeva-aqnyzLi7SQ"/><meta name="msvalidate.01" content="2A101DE4CB69400C01A80B1A89A62400"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?86df0317d9503122cab4c4dc5e8dcb55";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'javascript',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-07 01:34:26'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/user.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/bg/646.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Lemonxu's Blog"><span class="site-name">Lemonxu's Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">javascript</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-25T17:39:57.000Z" title="发表于 2023-06-25 17:39:57">2023-06-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-07T01:34:26.414Z" title="更新于 2023-09-07 01:34:26">2023-09-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/">基础</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/JavaScript/">JavaScript</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">20.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>75分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="javascript"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="JS基础"><a href="#JS基础" class="headerlink" title="JS基础"></a>JS基础</h1><h2 id="引入方式"><a href="#引入方式" class="headerlink" title="引入方式"></a>引入方式</h2><p>JavaScript有3种引入方式：行内式、嵌入式和外链式；</p>
<p>行内式：将JavaScript代码作为Html标签的属性值使用。示例如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:alert(&#x27;hello&#x27;)&quot;</span>&gt;</span>say hello<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>嵌入式：或称内嵌式，使用<code>script</code>标签包裹JavaScript代码，直接编写到html文件中，通常放到<code>&lt;head&gt;</code>和<code>&lt;body&gt;</code>或标签中。<code>&lt;script&gt;</code>中type用于告知浏览器脚本类型，html5中默认属性值为”text&#x2F;javascript”，因此，使用html5时可以省略type属性。示例如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    Javascript代码</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>外链式：也称外部式，将JavaScript代码写在一个单独的文件中，一般使用”js”作为文件的扩展名，在html</p>
<p>页面中使用<code>script</code>标签的src属性引入”js”文件。外链适合代码量较多的情况。示例如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./test.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>JavaScript是一种脚本语言，脚本通常以文本保存，只有在被调用的时候进行解释或编译。</p>
<p>JavaScript中必须严格区分大小写，例如Test和test是不同的；</p>
<p>JavaScript语句中每一行代码都要以英文的分号<code>;</code>结尾，如果不写分号，浏览器会自动添加，但会消耗一些系统资源；</p>
<p>JavaScript中会自动忽略多个空格和换行，所以可以使用空格和换行进行格式化；</p>
<p>JavaScript是弱类型语言，声明变量时可以不需要指定变量的类型。</p>
<h2 id="面向对象-x2F-设计模式-x2F-BOM-x2F-DOM"><a href="#面向对象-x2F-设计模式-x2F-BOM-x2F-DOM" class="headerlink" title="面向对象&#x2F;设计模式&#x2F;BOM&#x2F;DOM"></a>面向对象&#x2F;设计模式&#x2F;BOM&#x2F;DOM</h2><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="创建对象方式"><a href="#创建对象方式" class="headerlink" title="创建对象方式"></a>创建对象方式</h4><p>面向对象和面向过程都是编程思想。面向对象其实是面向过程的一种封装，例如：我要吃面条（面向过程：用多少面粉、多少水、怎么和面、怎么切面条、烧开水、煮面、吃面；面向对象：找到一个面馆、叫一碗面、等着吃）。</p>
<p>在ES6之前，JavaScript没有类的概念，但是可以使用函数来进行模拟，从而产生可复用的对象创建方式。</p>
<p><strong>创建对象的方式</strong>：工厂模式、构造函数模式、原型模式、组合使用构造函数模式和原型模式、动态原型模式、寄生构造函数模式；还有一些通过：{}、new Object()、使用字面量这三种都属于创建对象，只是这三种的都存在2个问题，一是代码冗余，二是对象中的方法不能共享，每个方法都是独立的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//工厂模式</span></span><br><span class="line"><span class="comment">//就是使用一个函数来创建对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createObject</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    o.<span class="property">name</span> = name;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o1 = <span class="title function_">createObject</span>(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="title function_">createObject</span>(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o1,o2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数模式(constructor)</span></span><br><span class="line"><span class="comment">//js每个函数都可以作为构造函数，只要一个函数是通过new来调用的，那么就可以把它成为构造函数。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createObject</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o1 = <span class="keyword">new</span> <span class="title function_">createObject</span>(<span class="string">&quot;test11&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> <span class="title function_">createObject</span>(<span class="string">&quot;test22&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o1,o2);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o1.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> == createObject); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//原型模式(prototype)</span></span><br><span class="line"><span class="comment">//因为每个函数都有一个prototype属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性方法。</span></span><br><span class="line"><span class="comment">/*这种方式解决了函数的复用问题，但这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个如果存在一个引用类型如Array这样的值，那么一个实例对引用值改变会影响所有实例。*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createObject</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">createObject.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;test&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> o1 = <span class="keyword">new</span> <span class="title function_">createObject</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(createObject.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> == createObject); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//组合使用构造函数模式和原型模式</span></span><br><span class="line"><span class="comment">/*解决原型模式的问题，构造函数初始化对象属性，共享引用类型数据导致数据错乱*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createObject</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line">createObject.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">constructor</span>: createObject,</span><br><span class="line">    <span class="attr">sayName</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o1 = <span class="keyword">new</span> <span class="title function_">createObject</span>(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> <span class="title function_">createObject</span>(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态原型模式</span></span><br><span class="line"><span class="comment">//这种模式将原型方法赋值创建过程移到了构造函数的内部，通过对属性是否存在的判断，实现仅在第一次调用函数时对原型对象赋值一次的效果。</span></span><br><span class="line"><span class="comment">//这种方式很好的对上面的混合模式进行了封装</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createObject</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="comment">//方法，仅会在需要时运行（一般是初次运行时）</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="variable language_">this</span>.<span class="property">sayName</span> != <span class="string">&quot;function&quot;</span>)&#123;</span><br><span class="line">        createObject.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">            <span class="attr">constructor</span>: createObject,</span><br><span class="line">            <span class="attr">sayName</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">createObject</span>(name); <span class="comment">//初次运行时，重新调用构造函数返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o1 = <span class="keyword">new</span> <span class="title function_">createObject</span>(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> <span class="title function_">createObject</span>(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o1, o2);</span><br><span class="line">o1.<span class="title function_">sayName</span>(); <span class="comment">//如果函数中没有return new createObject(name);则会显示Uncaught TypeError: p1.sayName is not a function</span></span><br><span class="line">o2.<span class="title function_">sayName</span>(); <span class="comment">//test2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//寄生构造函数模式</span></span><br><span class="line"><span class="comment">//这种模式和工厂模式的实现基本相同，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。</span></span><br><span class="line"><span class="comment">//例子1</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createObject</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    o.<span class="property">name</span> = name;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//例子2</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SpecialArray</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 创建数组</span></span><br><span class="line">  <span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">  <span class="comment">// 添加值</span></span><br><span class="line">  arr.<span class="property">push</span>.<span class="title function_">apply</span>(arr, <span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="comment">// 添加方法</span></span><br><span class="line">  arr.<span class="property">toPipedString</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">join</span>(<span class="string">&quot;|&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="title class_">SpecialArray</span>(<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors.<span class="title function_">toPipedString</span>()); <span class="comment">// &quot;red|blue|green&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="对象的继承方式"><a href="#对象的继承方式" class="headerlink" title="对象的继承方式"></a>对象的继承方式</h4><p>对象的继承方式主要有：原型链继承、借用构造函数方式、组合继承、原型式继承、寄生式继承、寄生式组合继承。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以原型链的方式实现继承</span></span><br><span class="line"><span class="comment">/*缺点就是在包含引用类型的数据时，会被所有的实例对象所共享，容易造成数据混乱，还有就是不能向超类型传递参数*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//借用构造函数的方式继承</span></span><br><span class="line"><span class="comment">/*通过在自来性的函数中调用超类型的构造函数来实现，解决不能向抄来性传递参数的缺点，但无法实现函数方法复用，并且超类型原型定义的方法子类型也无法访问*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//组合继承</span></span><br><span class="line"><span class="comment">//组合继承是将原型链和借用构造函数组合起来使用的一种方式。借用构造函数的方式来实现类型的属性继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。</span></span><br><span class="line"><span class="comment">/*解决了上面两种模式单独使用时的问题，但由于我们是以超类型的实例来作为子类的原型。所以调用了两次超类的构造函数，造成子类型的袁兴中多了很多不必要的属性*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//原型式继承</span></span><br><span class="line"><span class="comment">//主要思路就是基于已有的对象来创建新的对象，实现原理就是向函数中传入一个对象，然后返回以这个对象为原型的对象。这种继承思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单的继承。ES5中定义的Object.create()就是原型式继承。</span></span><br><span class="line"><span class="comment">/*缺点和原型链方式相同*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//寄生式继承</span></span><br><span class="line"><span class="comment">//思路是创建一个用于封装继承过程的函数，传入一个对象，然后复制对象的副本，然后对对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解成一种继承。</span></span><br><span class="line"><span class="comment">/*优点是对一个简单对象实现继承，如果这个对象不是自定义类型时。缺点就是没有办法实现函数的复用*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//寄生式组合继承</span></span><br><span class="line"><span class="comment">/*组合继承的缺点是使用超类型的实例作为子类型的原型，导致增加了不必要的原型属性。寄生式组合继承的方式就是使用超类型的原型副本作为子类的原型，避免创建不必要的属性*/</span></span><br></pre></td></tr></table></figure>



<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>设计模式分类为创建型（单例模式、原型模式、工厂模式、抽象工厂模式、建造者模式）、结构型（适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式）、行为型（观察者模式、迭代器模式、策略模式、模板方法模式、职责链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、发布-订阅模式）。</p>
<h4 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h4><p>（单例模式、原型模式、工厂模式、抽象工厂模式、建造者模式）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单例模式</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">优点：划分命名空间，减少全局变量；增强模块性，把自己的代码组织在一个全局变量名下，放在单一位置，便于维护；且只会实例化一次。简化了代码的调试和维护。</span></span><br><span class="line"><span class="comment">缺点：由于单例模式提供的是一种单点访问，所以它有可能导致模块间的强耦合 从而不利于单元测试。无法单独测试一个调用了来自单例的方法的类，而只能把它与那个单例作为一个单元一起测试。</span></span><br><span class="line"><span class="comment">场景例子：定义命名空间和实现分支型方法、登录框、vuex 和 redux中的store</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoginForm</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&#x27;hide&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">show</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&#x27;show&#x27;</span>) &#123;</span><br><span class="line">            <span class="title function_">alert</span>(<span class="string">&#x27;已经显示&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&#x27;show&#x27;</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;登录框显示成功&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">hide</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&#x27;hide&#x27;</span>) &#123;</span><br><span class="line">            <span class="title function_">alert</span>(<span class="string">&#x27;已经隐藏&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&#x27;hide&#x27;</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;登录框隐藏成功&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="title class_">LoginForm</span>.<span class="property">getInstance</span> = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">let</span> instance</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">LoginForm</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;)()</span><br><span class="line"><span class="keyword">let</span> obj1 = <span class="title class_">LoginForm</span>.<span class="title function_">getInstance</span>()</span><br><span class="line">obj1.<span class="title function_">show</span>()</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="title class_">LoginForm</span>.<span class="title function_">getInstance</span>()</span><br><span class="line">obj2.<span class="title function_">hide</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1 === obj2)</span><br><span class="line"></span><br><span class="line"><span class="comment">//原型模式：（prototype）是指用原型实例指向创建对象的种类，并且通过拷贝这些原型创建新的对象，就是创建一个共享的原型，通过拷贝这个原型来创建新的类，用于创建重复的对象，带来性能上的提升</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello， My name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> student = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;xiaoming&quot;</span>)</span><br><span class="line">student.<span class="title function_">sayHello</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂模式</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">优点：创建对象的过程可能很复杂，但我们只需要关心创建结果；构造函数和创建者分离, 符合“开闭原则”。一个调用者想创建一个对象，只要知道其名称就可以了。扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。</span></span><br><span class="line"><span class="comment">缺点：添加新产品时，需要编写新的具体产品类,一定程度上增加了系统的复杂度；考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">init</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;init&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">fun</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fun&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="title function_">create</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Product</span>(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// use</span></span><br><span class="line"><span class="keyword">let</span> factory = <span class="keyword">new</span> <span class="title class_">Factory</span>()</span><br><span class="line"><span class="keyword">let</span> p = factory.<span class="title function_">create</span>(<span class="string">&#x27;p1&#x27;</span>)</span><br><span class="line">p.<span class="title function_">init</span>()</span><br><span class="line">p.<span class="title function_">fun</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象工厂模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//建造者模式</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h4><p>（适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//适配器模式</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将一个类的接口转化为另外一个接口，以满足用户需求，使类之间接口不兼容问题通过适配器得以解决</span></span><br><span class="line"><span class="comment">优点：可以让任何两个没有关联的类一起运行；提高了类的复用；适配对象，适配库，适配数据；</span></span><br><span class="line"><span class="comment">缺点：额外对象的创建，非直接调用，存在一定的开销（且不像代理模式在某些功能点上可实现性能优化)；如果没必要使用适配器模式的话，可以考虑重构，如果使用的话，尽量把文档完善。</span></span><br><span class="line"><span class="comment">场景：整合第三方SDK、封装旧接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 自己封装的ajax， 使用方式如下</span></span><br><span class="line"><span class="title function_">ajax</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/getData&#x27;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;Post&#x27;</span>,</span><br><span class="line">    <span class="attr">dataType</span>: <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="number">111</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).<span class="title function_">done</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;)</span><br><span class="line"><span class="comment">// 因为历史原因，代码中全都是：</span></span><br><span class="line"><span class="comment">// $.ajax(&#123;....&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 做一层适配器</span></span><br><span class="line"><span class="keyword">var</span> $ = &#123;</span><br><span class="line">    <span class="attr">ajax</span>: <span class="keyword">function</span> (<span class="params">options</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">ajax</span>(options)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理模式：是为一个对象提供一个代用品或占位符，以便控制对它的访问</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">优点：代理模式能将代理对象与被调用对象分离，降低了系统的耦合度。代理模式在客户端和目标对象之间起到一个中介作用，这样可以起到保护目标对象的作用；代理对象可以扩展目标对象的功能；通过修改代理对象就可以了，符合开闭原则。</span></span><br><span class="line"><span class="comment">缺点：处理请求速度可能有差别，非直接访问存在开销</span></span><br><span class="line"><span class="comment">不同点：装饰者模式实现上和代理模式类似，装饰者模式： 扩展功能，原有功能不变且可直接使用；代理模式： 显示原有功能，但是经过限制之后的。</span></span><br><span class="line"><span class="comment">场景：HTML元 素事件代理、ES6 的 proxy、jQuery.proxy()方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&lt;ul id=<span class="string">&quot;ul&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> ul = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#ul&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  ul.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">target</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//装饰器模式：动态地给某个对象添加一些额外的职责，是一种实现继承的替代方案；在不改变原对象的基础上，通过对其进行包装扩展，使原有对象可以满足用户的更复杂需求，而不会影响从这个类中派生的其他对象</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">优点：装饰类和被装饰类都只关心自身的核心业务，实现了解耦；方便动态的扩展功能，且提供了比继承更多的灵活性。</span></span><br><span class="line"><span class="comment">缺点：多层装饰比较复杂；常常会引入许多小对象，看起来比较相似，实际功能大相径庭，从而使得我们的应用程序架构变得复杂起来；</span></span><br><span class="line"><span class="comment">场景：比如现在有4 种型号的自行车，我们为每种自行车都定义了一个单独的类。现在要给每种自行车都装上前灯、尾灯和铃铛这3 种配件。如果使用继承的方式来给每种自行车创建子类，则需要 4×3 = 12 个子类。但是如果把前灯、尾灯、铃铛这些对象动态组合到自行车上面，则只需要额外增加3 个类；ES7 Decorator；core-decorators。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cellphone</span> &#123;</span><br><span class="line">    <span class="title function_">create</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;生成一个手机&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Decorator</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">cellphone</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cellphone</span> = cellphone</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">create</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cellphone</span>.<span class="title function_">create</span>()</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">createShell</span>(cellphone)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">createShell</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;生成手机壳&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> cellphone = <span class="keyword">new</span> <span class="title class_">Cellphone</span>()</span><br><span class="line">cellphone.<span class="title function_">create</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;------------&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> dec = <span class="keyword">new</span> <span class="title class_">Decorator</span>(cellphone)</span><br><span class="line">dec.<span class="title function_">create</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//外观模式：为子系统的一组接口提供一个一致的界面，定义了一个高层接口，这个接口使子系统更加容易使用</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">优点：减少系统相互依赖；提高灵活性；提高了安全性。</span></span><br><span class="line"><span class="comment">缺点：不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。</span></span><br><span class="line"><span class="comment">场景：设计初期，应该要有意识地将不同的两个层分离，比如经典的三层结构，在数据访问层和业务逻辑层、业务逻辑层和表示层之间建立外观Facade；在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂，增加外观Facade可以提供一个简单的接口，减少他们之间的依赖；在维护一个遗留的大型系统时，可能这个系统已经很难维护了，这时候使用外观Facade也是非常合适的，为系系统开发一个外观Facade类，为设计粗糙和高度复杂的遗留代码提供比较清晰的接口，让新系统和Facade对象交互，Facade与遗留代码交互所有的复杂工作。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> addMyEvent = <span class="keyword">function</span> (<span class="params">el, ev, fn</span>) &#123;</span><br><span class="line">    <span class="comment">//兼容浏览器事件绑定</span></span><br><span class="line">    <span class="keyword">if</span> (el.<span class="property">addEventListener</span>) &#123;</span><br><span class="line">        el.<span class="title function_">addEventListener</span>(ev, fn, <span class="literal">false</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.<span class="property">attachEvent</span>) &#123;</span><br><span class="line">        el.<span class="title function_">attachEvent</span>(<span class="string">&#x27;on&#x27;</span> + ev, fn)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        el[<span class="string">&#x27;on&#x27;</span> + ev] = fn</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> myEvent = &#123;</span><br><span class="line">    <span class="comment">//封装接口</span></span><br><span class="line">    <span class="attr">stop</span>: <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        e.<span class="title function_">stopPropagation</span>();</span><br><span class="line">        e.<span class="title function_">preventDefault</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//桥接模式：将抽象部分与它的实现部分分离，使它们都可以独立地变化</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">优点：有助于独立地管理各组成部分， 把抽象化与实现化解耦；提高可扩充性。</span></span><br><span class="line"><span class="comment">缺点：大量的类将导致开发成本的增加，同时在性能方面可能也会有所减少。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name,color</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">color</span> = color </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">draw</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.color.name&#125;</span> <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> red = <span class="keyword">new</span> <span class="title class_">Color</span>(<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> yellow = <span class="keyword">new</span> <span class="title class_">Color</span>(<span class="string">&#x27;yellow&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> circle = <span class="keyword">new</span> <span class="title class_">Shape</span>(<span class="string">&#x27;circle&#x27;</span>, red)</span><br><span class="line">circle.<span class="title function_">draw</span>()</span><br><span class="line"><span class="keyword">let</span> triangle = <span class="keyword">new</span> <span class="title class_">Shape</span>(<span class="string">&#x27;triangle&#x27;</span>, yellow)</span><br><span class="line">triangle.<span class="title function_">draw</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//组合模式：将对象组合成树形结构，以表示“整体-部分”的层次结构；通过对象的多态表现，使得用户对单个对象和组合对象的使用具有一致性</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">缺点：如果通过组合模式创建了太多的对象，那么这些对象可能会让系统负担不起</span></span><br><span class="line"><span class="comment">场景：表示对象-整体层次结构；希望用户忽略组合对象和单个对象的不同，用户将统一地使用组合结构中的所有对象（方法）。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrainOrder</span> &#123;</span><br><span class="line">	create () &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;创建火车票订单&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HotelOrder</span> &#123;</span><br><span class="line">	create () &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;创建酒店订单&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TotalOrder</span> &#123;</span><br><span class="line">	<span class="title function_">constructor</span> () &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">orderList</span> = []</span><br><span class="line">	&#125;</span><br><span class="line">	addOrder (order) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">orderList</span>.<span class="title function_">push</span>(order)</span><br><span class="line">		<span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">	&#125;</span><br><span class="line">	create () &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">orderList</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">			item.<span class="title function_">create</span>()</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以在购票网站买车票同时也订房间</span></span><br><span class="line"><span class="keyword">let</span> train = <span class="keyword">new</span> <span class="title class_">TrainOrder</span>()</span><br><span class="line"><span class="keyword">let</span> hotel = <span class="keyword">new</span> <span class="title class_">HotelOrder</span>()</span><br><span class="line"><span class="keyword">let</span> total = <span class="keyword">new</span> <span class="title class_">TotalOrder</span>()</span><br><span class="line">total.<span class="title function_">addOrder</span>(train).<span class="title function_">addOrder</span>(hotel).<span class="title function_">create</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//享元模式：运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">优点：大大减少对象的创建，降低系统的内存，使效率提高。</span></span><br><span class="line"><span class="comment">缺点：提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质， 不应该随着内部状态的变化而变化，否则会造成系统的混乱</span></span><br><span class="line"><span class="comment">场景：文件上传需要创建多个文件实例的时候、如果一个应用程序使用了大量的对象，而这些大量的对象造成了很大的存储开销时就应该考虑使用享元模式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> examCarNum = <span class="number">0</span>         <span class="comment">// 驾考车总数</span></span><br><span class="line"><span class="comment">/* 驾考车对象 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExamCar</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">carType</span>) &#123;</span><br><span class="line">        examCarNum++</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">carId</span> = examCarNum</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">carType</span> = carType ? <span class="string">&#x27;手动档&#x27;</span> : <span class="string">&#x27;自动档&#x27;</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">usingState</span> = <span class="literal">false</span>    <span class="comment">// 是否正在使用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 在本车上考试 */</span></span><br><span class="line">    <span class="title function_">examine</span>(<span class="params">candidateId</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>((<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">usingState</span> = <span class="literal">true</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`考生- <span class="subst">$&#123; candidateId &#125;</span> 开始在<span class="subst">$&#123; <span class="variable language_">this</span>.carType &#125;</span>驾考车- <span class="subst">$&#123; <span class="variable language_">this</span>.carId &#125;</span> 上考试`</span>)</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">usingState</span> = <span class="literal">false</span></span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`%c考生- <span class="subst">$&#123; candidateId &#125;</span> 在<span class="subst">$&#123; <span class="variable language_">this</span>.carType &#125;</span>驾考车- <span class="subst">$&#123; <span class="variable language_">this</span>.carId &#125;</span> 上考试完毕`</span>, <span class="string">&#x27;color:#f40&#x27;</span>)</span><br><span class="line">                <span class="title function_">resolve</span>()                       <span class="comment">// 0~2秒后考试完毕</span></span><br><span class="line">            &#125;, <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">2000</span>)</span><br><span class="line">        &#125;))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 手动档汽车对象池 */</span></span><br><span class="line"><span class="title class_">ManualExamCarPool</span> = &#123;</span><br><span class="line">    <span class="attr">_pool</span>: [],                  <span class="comment">// 驾考车对象池</span></span><br><span class="line">    <span class="attr">_candidateQueue</span>: [],        <span class="comment">// 考生队列</span></span><br><span class="line">    <span class="comment">/* 注册考生 ID 列表 */</span></span><br><span class="line">    <span class="title function_">registCandidates</span>(<span class="params">candidateList</span>) &#123;</span><br><span class="line">        candidateList.<span class="title function_">forEach</span>(<span class="function"><span class="params">candidateId</span> =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">registCandidate</span>(candidateId))</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/* 注册手动档考生 */</span></span><br><span class="line">    <span class="title function_">registCandidate</span>(<span class="params">candidateId</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> examCar = <span class="variable language_">this</span>.<span class="title function_">getManualExamCar</span>()    <span class="comment">// 找一个未被占用的手动档驾考车</span></span><br><span class="line">        <span class="keyword">if</span> (examCar) &#123;</span><br><span class="line">            examCar.<span class="title function_">examine</span>(candidateId)           <span class="comment">// 开始考试，考完了让队列中的下一个考生开始考试</span></span><br><span class="line">              .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                  <span class="keyword">const</span> nextCandidateId = <span class="variable language_">this</span>.<span class="property">_candidateQueue</span>.<span class="property">length</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">_candidateQueue</span>.<span class="title function_">shift</span>()</span><br><span class="line">                  nextCandidateId &amp;&amp; <span class="variable language_">this</span>.<span class="title function_">registCandidate</span>(nextCandidateId)</span><br><span class="line">              &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="variable language_">this</span>.<span class="property">_candidateQueue</span>.<span class="title function_">push</span>(candidateId)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/* 注册手动档车 */</span></span><br><span class="line">    <span class="title function_">initManualExamCar</span>(<span class="params">manualExamCarNum</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= manualExamCarNum; i++) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">_pool</span>.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">ExamCar</span>(<span class="literal">true</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/* 获取状态为未被占用的手动档车 */</span></span><br><span class="line">    <span class="title function_">getManualExamCar</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_pool</span>.<span class="title function_">find</span>(<span class="function"><span class="params">car</span> =&gt;</span> !car.<span class="property">usingState</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ManualExamCarPool</span>.<span class="title function_">initManualExamCar</span>(<span class="number">3</span>);          <span class="comment">// 一共有3个驾考车</span></span><br><span class="line"><span class="title class_">ManualExamCarPool</span>.<span class="title function_">registCandidates</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]);  <span class="comment">// 10个考生来考试</span></span><br></pre></td></tr></table></figure>

<h4 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h4><p>（观察者模式、迭代器模式、策略模式、模板方法模式、职责链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、发布-订阅模式）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//观察者模式（发布-订阅模式）:定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使它们能够自动更新自己，当一个对象的改变需要同时改变其它对象，并且它不知道具体有多少对象需要改变的时候，就应该考虑使用观察者模式。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">优点：支持简单的广播通信，自动通知所有已经订阅过的对象；目标对象与观察者之间的抽象耦合关系能单独扩展以及重用；增加了灵活性；观察者模式所做的工作就是在解耦，让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响到另一边的变化。</span></span><br><span class="line"><span class="comment">缺点：过度使用会导致对象与对象之间的联系弱化，会导致程序难以跟踪维护和理解</span></span><br><span class="line"><span class="comment">场景：DOM事件、vue 响应式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 主题 保存状态，状态变化之后触发所有观察者对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = <span class="number">0</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observers</span> = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getState</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">setState</span>(<span class="params">state</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = state</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">notifyAllObservers</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">notifyAllObservers</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">      observer.<span class="title function_">update</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">attach</span>(<span class="params">observer</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">push</span>(observer)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, subject</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subject</span> = subject</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subject</span>.<span class="title function_">attach</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> update, state: <span class="subst">$&#123;<span class="variable language_">this</span>.subject.getState()&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="title class_">Subject</span>()</span><br><span class="line"><span class="keyword">let</span> o1 = <span class="keyword">new</span> <span class="title class_">Observer</span>(<span class="string">&#x27;o1&#x27;</span>, s)</span><br><span class="line"><span class="keyword">let</span> o2 = <span class="keyword">new</span> <span class="title class_">Observer</span>(<span class="string">&#x27;02&#x27;</span>, s)</span><br><span class="line">s.<span class="title function_">setState</span>(<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器模式：提供一种方法顺序一个聚合对象中各个元素，而又不暴露该对象的内部标识。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">特点：访问一个聚合对象的内容而无需暴露它的内部表示；为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作。对于集合内部结果常常变化各异，不想暴露其内部结构的话，但又想让客户代码透明的访问其中的元素，可以使用迭代器模式。</span></span><br><span class="line"><span class="comment">场景：Array.prototype.forEach、jQuery中的$.each()、ES6 Iterator</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">conatiner</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">list</span> = conatiner.<span class="property">list</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">index</span> = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">hasNext</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">list</span>[<span class="variable language_">this</span>.<span class="property">index</span>++]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">hasNext</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">index</span> &gt;= <span class="variable language_">this</span>.<span class="property">list</span>.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">list</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">list</span> = list</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">getIterator</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> container = <span class="keyword">new</span> <span class="title class_">Container</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="keyword">let</span> iterator = container.<span class="title function_">getIterator</span>()</span><br><span class="line"><span class="keyword">while</span>(iterator.<span class="title function_">hasNext</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//策略模式：定义一系列的算法，把它们一个个封装起来，并且使它们可以互相替换</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">优点:利用组合、委托、多态等技术和思想，可以有效的避免多重条件选择语句;提供了对开放-封闭原则的完美支持，将算法封装在独立的strategy中，使得它们易于切换，理解，易于扩展;利用组合和委托来让Context拥有执行算法的能力，这也是继承的一种更轻便的代替方案</span></span><br><span class="line"><span class="comment">缺点:会在程序中增加许多策略类或者策略对象;要使用策略模式，必须了解所有的strategy，必须了解各个strategy之间的不同点，这样才能选择一个合适的strategy。</span></span><br><span class="line"><span class="comment">场景：如果在一个系统里面有许多类，它们之间的区别仅在于它们的&#x27;行为&#x27;，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为；一个系统需要动态地在几种算法中选择一种；表单验证</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;策略模式-校验表单&lt;/title&gt;</span><br><span class="line">    &lt;meta content=&quot;text/html; charset=utf-8&quot; http-equiv=&quot;Content-Type&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form id = &quot;registerForm&quot; method=&quot;post&quot; action=&quot;http://xxxx.com/api/register&quot;&gt;</span><br><span class="line">        用户名：&lt;input type=&quot;text&quot; name=&quot;userName&quot;&gt;</span><br><span class="line">        密码：&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt;</span><br><span class="line">        手机号码：&lt;input type=&quot;text&quot; name=&quot;phoneNumber&quot;&gt;</span><br><span class="line">        &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        // 策略对象</span><br><span class="line">        const strategies = &#123;</span><br><span class="line">          isNoEmpty: function (value, errorMsg) &#123;</span><br><span class="line">            if (value === &#x27;&#x27;) &#123;</span><br><span class="line">              return errorMsg;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          isNoSpace: function (value, errorMsg) &#123;</span><br><span class="line">            if (value.trim() === &#x27;&#x27;) &#123;</span><br><span class="line">              return errorMsg;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          minLength: function (value, length, errorMsg) &#123;</span><br><span class="line">            if (value.trim().length &lt; length) &#123;</span><br><span class="line">              return errorMsg;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          maxLength: function (value, length, errorMsg) &#123;</span><br><span class="line">            if (value.length &gt; length) &#123;</span><br><span class="line">              return errorMsg;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          isMobile: function (value, errorMsg) &#123;</span><br><span class="line">            if (!/^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|17[7]|18[0|1|2|3|5|6|7|8|9])\d&#123;8&#125;$/.test(value)) &#123;</span><br><span class="line">              return errorMsg;</span><br><span class="line">            &#125;                </span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 验证类</span><br><span class="line">        class Validator &#123;</span><br><span class="line">          constructor() &#123;</span><br><span class="line">            this.cache = []</span><br><span class="line">          &#125;</span><br><span class="line">          add(dom, rules) &#123;</span><br><span class="line">            for(let i = 0, rule; rule = rules[i++];) &#123;</span><br><span class="line">              let strategyAry = rule.strategy.split(&#x27;:&#x27;)</span><br><span class="line">              let errorMsg = rule.errorMsg</span><br><span class="line">              this.cache.push(() =&gt; &#123;</span><br><span class="line">                let strategy = strategyAry.shift()</span><br><span class="line">                strategyAry.unshift(dom.value)</span><br><span class="line">                strategyAry.push(errorMsg)</span><br><span class="line">                return strategies[strategy].apply(dom, strategyAry)</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          start() &#123;</span><br><span class="line">            for(let i = 0, validatorFunc; validatorFunc = this.cache[i++];) &#123;</span><br><span class="line">              let errorMsg = validatorFunc()</span><br><span class="line">              if (errorMsg) &#123;</span><br><span class="line">                return errorMsg</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 调用代码</span><br><span class="line">        let registerForm = document.getElementById(&#x27;registerForm&#x27;)</span><br><span class="line"></span><br><span class="line">        let validataFunc = function() &#123;</span><br><span class="line">          let validator = new Validator()</span><br><span class="line">          validator.add(registerForm.userName, [&#123;</span><br><span class="line">            strategy: &#x27;isNoEmpty&#x27;,</span><br><span class="line">            errorMsg: &#x27;用户名不可为空&#x27;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            strategy: &#x27;isNoSpace&#x27;,</span><br><span class="line">            errorMsg: &#x27;不允许以空白字符命名&#x27;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            strategy: &#x27;minLength:2&#x27;,</span><br><span class="line">            errorMsg: &#x27;用户名长度不能小于2位&#x27;</span><br><span class="line">          &#125;])</span><br><span class="line">          validator.add(registerForm.password, [ &#123;</span><br><span class="line">            strategy: &#x27;minLength:6&#x27;,</span><br><span class="line">            errorMsg: &#x27;密码长度不能小于6位&#x27;</span><br><span class="line">          &#125;])</span><br><span class="line">          validator.add(registerForm.phoneNumber, [&#123;</span><br><span class="line">            strategy: &#x27;isMobile&#x27;,</span><br><span class="line">            errorMsg: &#x27;请输入正确的手机号码格式&#x27;</span><br><span class="line">          &#125;])</span><br><span class="line">          return validator.start()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        registerForm.onsubmit = function() &#123;</span><br><span class="line">          let errorMsg = validataFunc()</span><br><span class="line">          if (errorMsg) &#123;</span><br><span class="line">            alert(errorMsg)</span><br><span class="line">            return false</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">//模板方法模式：模板方法模式由两部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类。通常在抽象父类中封装了子类的算法框架，包括实现一些公共方法和封装子类中所有方法的执行顺序。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。</span><br><span class="line">/*</span><br><span class="line">优点：提取了公共代码部分，易于维护；</span><br><span class="line">缺点：增加了系统复杂度，主要是增加了的抽象类和类间联系；</span><br><span class="line">场景：一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现；子类中公共的行为应被提取出来并集中到一个公共父类中的避免代码重复。</span><br><span class="line">*/</span><br><span class="line">class Beverage &#123;</span><br><span class="line">    constructor(&#123;brewDrink, addCondiment&#125;) &#123;</span><br><span class="line">        this.brewDrink = brewDrink</span><br><span class="line">        this.addCondiment = addCondiment</span><br><span class="line">    &#125;</span><br><span class="line">    /* 烧开水，共用方法 */</span><br><span class="line">    boilWater() &#123; console.log(&#x27;水已经煮沸=== 共用&#x27;) &#125;</span><br><span class="line">    /* 倒杯子里，共用方法 */</span><br><span class="line">    pourCup() &#123; console.log(&#x27;倒进杯子里===共用&#x27;) &#125;</span><br><span class="line">    /* 模板方法 */</span><br><span class="line">    init() &#123;</span><br><span class="line">        this.boilWater()</span><br><span class="line">        this.brewDrink()</span><br><span class="line">        this.pourCup()</span><br><span class="line">        this.addCondiment()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/* 咖啡 */</span><br><span class="line">const coffee = new Beverage(&#123;</span><br><span class="line">     /* 冲泡咖啡，覆盖抽象方法 */</span><br><span class="line">     brewDrink: function() &#123; console.log(&#x27;冲泡咖啡&#x27;) &#125;,</span><br><span class="line">     /* 加调味品，覆盖抽象方法 */</span><br><span class="line">     addCondiment: function() &#123; console.log(&#x27;加点奶和糖&#x27;) &#125;</span><br><span class="line">&#125;)</span><br><span class="line">coffee.init() </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//职责链模式：使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止</span><br><span class="line">/*</span><br><span class="line">优点:降低耦合度。它将请求的发送者和接收者解耦；简化了对象。使得对象不需要知道链的结构;增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任；增加新的请求处理类很方便。</span><br><span class="line">缺点：不能保证某个请求一定会被链中的节点处理，这种情况可以在链尾增加一个保底的接受者节点来处理这种即将离开链尾的请求；使程序中多了很多节点对象，可能再一次请求的过程中，大部分的节点并没有起到实质性的作用。他们的作用仅仅是让请求传递下去，从性能当面考虑，要避免过长的职责链到来的性能损耗。</span><br><span class="line">场景：JS 中的事件冒泡、作用域链、原型链</span><br><span class="line">*/</span><br><span class="line">// 请假审批，需要组长审批、经理审批、总监审批</span><br><span class="line">class Action &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        this.name = name</span><br><span class="line">        this.nextAction = null</span><br><span class="line">    &#125;</span><br><span class="line">    setNextAction(action) &#123;</span><br><span class="line">        this.nextAction = action</span><br><span class="line">    &#125;</span><br><span class="line">    handle() &#123;</span><br><span class="line">        console.log( `$&#123;this.name&#125; 审批`)</span><br><span class="line">        if (this.nextAction != null) &#123;</span><br><span class="line">            this.nextAction.handle()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a1 = new Action(&quot;组长&quot;)</span><br><span class="line">let a2 = new Action(&quot;经理&quot;)</span><br><span class="line">let a3 = new Action(&quot;总监&quot;)</span><br><span class="line">a1.setNextAction(a2)</span><br><span class="line">a2.setNextAction(a3)</span><br><span class="line">a1.handle()</span><br><span class="line"></span><br><span class="line">//命令模式：将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。</span><br><span class="line">/*</span><br><span class="line">优点：对命令进行封装，使命令易于扩展和修改；命令发出者和接受者解耦，使发出者不需要知道命令的具体执行过程即可执行。</span><br><span class="line">缺点：使用命令模式可能会导致某些系统有过多的具体命令类。</span><br><span class="line">*/</span><br><span class="line">// 接收者类</span><br><span class="line">class Receiver &#123;</span><br><span class="line">    execute() &#123;</span><br><span class="line">      console.log(&#x27;接收者执行请求&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 命令者</span><br><span class="line">class Command &#123;  </span><br><span class="line">    constructor(receiver) &#123;</span><br><span class="line">        this.receiver = receiver</span><br><span class="line">    &#125;</span><br><span class="line">    execute () &#123;    </span><br><span class="line">        console.log(&#x27;命令&#x27;);</span><br><span class="line">        this.receiver.execute()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 触发者</span><br><span class="line">class Invoker &#123;   </span><br><span class="line">    constructor(command) &#123;</span><br><span class="line">        this.command = command</span><br><span class="line">    &#125;</span><br><span class="line">    invoke() &#123;   </span><br><span class="line">        console.log(&#x27;开始&#x27;)</span><br><span class="line">        this.command.execute()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 仓库</span><br><span class="line">const warehouse = new Receiver();   </span><br><span class="line">// 订单    </span><br><span class="line">const order = new Command(warehouse);  </span><br><span class="line">// 客户</span><br><span class="line">const client = new Invoker(order);      </span><br><span class="line">client.invoke()</span><br><span class="line"></span><br><span class="line">//备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。</span><br><span class="line">/*</span><br><span class="line">优点：给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。</span><br><span class="line">缺点：消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。</span><br><span class="line">场景：分页控件、撤销组件</span><br><span class="line">*/</span><br><span class="line">//备忘类</span><br><span class="line">class Memento&#123;</span><br><span class="line">    constructor(content)&#123;</span><br><span class="line">        this.content = content</span><br><span class="line">    &#125;</span><br><span class="line">    getContent()&#123;</span><br><span class="line">        return this.content</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 备忘列表</span><br><span class="line">class CareTaker &#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.list = []</span><br><span class="line">    &#125;</span><br><span class="line">    add(memento)&#123;</span><br><span class="line">        this.list.push(memento)</span><br><span class="line">    &#125;</span><br><span class="line">    get(index)&#123;</span><br><span class="line">        return this.list[index]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 编辑器</span><br><span class="line">class Editor &#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.content = null</span><br><span class="line">    &#125;</span><br><span class="line">    setContent(content)&#123;</span><br><span class="line">        this.content = content</span><br><span class="line">    &#125;</span><br><span class="line">    getContent()&#123;</span><br><span class="line">     return this.content</span><br><span class="line">    &#125;</span><br><span class="line">    saveContentToMemento()&#123;</span><br><span class="line">        return new Memento(this.content)</span><br><span class="line">    &#125;</span><br><span class="line">    getContentFromMemento(memento)&#123;</span><br><span class="line">        this.content = memento.getContent()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//测试代码</span><br><span class="line"></span><br><span class="line">let editor = new Editor()</span><br><span class="line">let careTaker = new CareTaker()</span><br><span class="line">editor.setContent(&#x27;111&#x27;)</span><br><span class="line">editor.setContent(&#x27;222&#x27;)</span><br><span class="line">careTaker.add(editor.saveContentToMemento())</span><br><span class="line">editor.setContent(&#x27;333&#x27;)</span><br><span class="line">careTaker.add(editor.saveContentToMemento())</span><br><span class="line">editor.setContent(&#x27;444&#x27;)</span><br><span class="line">console.log(editor.getContent()) //444</span><br><span class="line">editor.getContentFromMemento(careTaker.get(1))</span><br><span class="line">console.log(editor.getContent()) //333</span><br><span class="line">editor.getContentFromMemento(careTaker.get(0))</span><br><span class="line">console.log(editor.getContent()) //222</span><br><span class="line"></span><br><span class="line">//状态模式：允许一个对象在其内部状态改变的时候改变它的行为，对象看起来似乎修改了它的类</span><br><span class="line">/*</span><br><span class="line">优点：定义了状态与行为之间的关系，封装在一个类里，更直观清晰，增改方便；状态与状态间，行为与行为间彼此独立互不干扰；用对象代替字符串来记录当前状态，使得状态的切换更加一目了然。</span><br><span class="line">缺点：会在系统中定义许多状态类；逻辑分散。</span><br><span class="line">场景：一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为、一个操作中含有大量的分支语句，而且这些分支语句依赖于该对象的状态。</span><br><span class="line">*/</span><br><span class="line">// 状态 （弱光、强光、关灯）</span><br><span class="line">class State &#123;</span><br><span class="line">    constructor(state) &#123;</span><br><span class="line">        this.state = state</span><br><span class="line">    &#125;</span><br><span class="line">    handle(context) &#123;</span><br><span class="line">        console.log(`this is $&#123;this.state&#125; light`)</span><br><span class="line">        context.setState(this)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Context &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.state = null</span><br><span class="line">    &#125;</span><br><span class="line">    getState() &#123;</span><br><span class="line">        return this.state</span><br><span class="line">    &#125;</span><br><span class="line">    setState(state) &#123;</span><br><span class="line">        this.state = state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// test </span><br><span class="line">let context = new Context()</span><br><span class="line">let weak = new State(&#x27;weak&#x27;)</span><br><span class="line">let strong = new State(&#x27;strong&#x27;)</span><br><span class="line">let off = new State(&#x27;off&#x27;)</span><br><span class="line">// 弱光</span><br><span class="line">weak.handle(context)</span><br><span class="line">console.log(context.getState())</span><br><span class="line">// 强光</span><br><span class="line">strong.handle(context)</span><br><span class="line">console.log(context.getState())</span><br><span class="line">// 关闭</span><br><span class="line">off.handle(context)</span><br><span class="line">console.log(context.getState())</span><br><span class="line"></span><br><span class="line">//访问者模式：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</span><br><span class="line">/*</span><br><span class="line">优点：符合单一职责原则；优秀的扩展性；灵活性。</span><br><span class="line">缺点：具体元素对访问者公布细节，违反了迪米特原则；违反了依赖倒置原则，依赖了具体类，没有依赖抽象；具体元素变更比较困难。</span><br><span class="line">场景：对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作、需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作&quot;污染&quot;这些对象的类，也不希望在增加新操作时修改这些类。</span><br><span class="line">*/</span><br><span class="line">// 访问者  </span><br><span class="line">class Visitor &#123;</span><br><span class="line">    constructor() &#123;&#125;</span><br><span class="line">    visitConcreteElement(ConcreteElement) &#123;</span><br><span class="line">        ConcreteElement.operation()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 元素类  </span><br><span class="line">class ConcreteElement&#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    operation() &#123;</span><br><span class="line">       console.log(&quot;ConcreteElement.operation invoked&quot;);  </span><br><span class="line">    &#125;</span><br><span class="line">    accept(visitor) &#123;</span><br><span class="line">        visitor.visitConcreteElement(this)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// client</span><br><span class="line">let visitor = new Visitor()</span><br><span class="line">let element = new ConcreteElement()</span><br><span class="line">element.accept(visitor)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//中介者模式：解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者对象即可。中介者使各对象之间耦合松散，而且可以独立地改变它们之间的交互。中介者模式使网状的多对多关系变成了相对简单的一对多关系（类似于观察者模式，但是单向的，由中介者统一管理。）</span><br><span class="line">/*</span><br><span class="line">优点：使各对象之间耦合松散，而且可以独立地改变它们之间的交互；中介者和对象一对多的关系取代了对象之间的网状多对多的关系；如果对象之间的复杂耦合度导致维护很困难，而且耦合度随项目变化增速很快，就需要中介者重构代码。</span><br><span class="line">缺点：系统中会新增一个中介者对象，因 为对象之间交互的复杂性，转移成了中介者对象的复杂性，使得中介者对象经常是巨大的。中介 者对象自身往往就是一个难以维护的对象。</span><br><span class="line">场景：系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象、想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。</span><br><span class="line">*/</span><br><span class="line">class A &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.number = 0</span><br><span class="line">    &#125;</span><br><span class="line">    setNumber(num, m) &#123;</span><br><span class="line">        this.number = num</span><br><span class="line">        if (m) &#123;</span><br><span class="line">            m.setB()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class B &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.number = 0</span><br><span class="line">    &#125;</span><br><span class="line">    setNumber(num, m) &#123;</span><br><span class="line">        this.number = num</span><br><span class="line">        if (m) &#123;</span><br><span class="line">            m.setA()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Mediator &#123;</span><br><span class="line">    constructor(a, b) &#123;</span><br><span class="line">        this.a = a</span><br><span class="line">        this.b = b</span><br><span class="line">    &#125;</span><br><span class="line">    setA() &#123;</span><br><span class="line">        let number = this.b.number</span><br><span class="line">        this.a.setNumber(number * 10)</span><br><span class="line">    &#125;</span><br><span class="line">    setB() &#123;</span><br><span class="line">        let number = this.a.number</span><br><span class="line">        this.b.setNumber(number / 10)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = new A()</span><br><span class="line">let b = new B()</span><br><span class="line">let m = new Mediator(a, b)</span><br><span class="line">a.setNumber(10, m)</span><br><span class="line">console.log(a.number, b.number)</span><br><span class="line">b.setNumber(10, m)</span><br><span class="line">console.log(a.number, b.number)</span><br></pre></td></tr></table></figure>



<h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><p>BOM指的是浏览器对象模型，是指把浏览器当做一个对象来对待，这个对象主要定义了与浏览器交互的方法与接口。</p>
<p>BOM的核心就是window，而window对象具有双重角色，它既是通过js访问浏览器窗口的一个接口，又是一个Global（全局）对象。这意味着在网页中定义的任何对象、变量和函数，都作为全局对象的一个属性或方法存在。window对象包含localtion对象、navigator对象、screen对象等子对象，并且DOM最根本的对象document对象也是BOM的window对象的子对象。</p>
<h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>DOM指的是文档对象模型，是指把文档当做一个对象，这个对象主要定义了处理网页内容的方法和接口。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h4 id="数据类型种类（8种）"><a href="#数据类型种类（8种）" class="headerlink" title="数据类型种类（8种）"></a>数据类型种类（8种）</h4><p>JavaScript的数据类型，共有8中数据类型：undefined、null、Boolean、Number、String、Object、Symbol、BigInt。</p>
<p>其中Symbol和BigInt是ES6新增的数据类型：</p>
<p><strong>Symbol</strong>代表创建后独一无二且不可变的数据类型，主要为了解决可能出现的全局变量冲突的问题;</p>
<p><strong>BigInt</strong>是一种数字类型，可以表示任意精度格式的整数，使用BigInt可以安全地存储和操作大数据，即使这个数已经超出了Number能够表示的安全整数范围。</p>
<p>数据可以分为：原始数据类型和引用数据类型。</p>
<p>栈（stack）（原始数据类型）：<code>undefined、null、Boolean、Number、String、Symbol、BigInt</code>；</p>
<p>原始数据类型直接存储在栈中的简单数据段，占据空间小、大小固定，属于被频繁使用的数据，所以放入栈中存储。在数据结构中，栈中的数据存储方式是先进后出。</p>
<p>堆（heap）（引用数据类型）：<code>对象Object、数组Array、函数</code>；</p>
<p>引用数据类型存储在堆中的对象，占据空间大，大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。在数据结构中，堆是一个优先队列，是按照优先级来进行排序的，优先级可以按照大小来规定。</p>
<p>（操作系统内存被分为栈区和堆区：栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似数据结构中的栈；堆区内存一般由开发者分配释放，若开发者不释放，程序结束时可能由垃圾回收机制回收。）</p>
<p><strong>null和undefined的区别</strong>：两者都属于基本数据类型，分别只有一个值。</p>
<p>undefined代表未定义，null代表的是空对象。</p>
<p>typeof null会返回Object。undefined的值是（-2）30（一个超出整数范围的数字）；null的机器码是NULL指针（null指针的值全是0，也就是null的类型标签为000，和Object的类型标签一样，所以会被判定为Object）。</p>
<p>Boolean(布尔类型的假值)：undefined、null、+0、-0、false、””、NaN。</p>
<h4 id="数据类型检测方法（4种）"><a href="#数据类型检测方法（4种）" class="headerlink" title="数据类型检测方法（4种）"></a>数据类型检测方法（4种）</h4><ul>
<li><strong>typeof</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">2</span>); <span class="comment">//number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">true</span>); <span class="comment">//boolean</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="string">&#x27;str&#x27;</span>); <span class="comment">//string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> []); <span class="comment">//object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;); <span class="comment">//function</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> &#123;&#125;);  <span class="comment">//object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">undefined</span>);  <span class="comment">//undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">null</span>); <span class="comment">//object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">NaN</span>); <span class="comment">//number</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>instanceof</strong></li>
</ul>
<p>可以正确判断对象类型，内部运行机制是判断在其原型链中是否能找到该类型的原型。</p>
<p><code>instanceof</code>只能正确判断引用数据类型，而不能判断基本数据类型。<code>instanceof</code>运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的<code>prototype</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span> <span class="keyword">instanceof</span> <span class="title class_">Number</span>); <span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">true</span> <span class="keyword">instanceof</span> <span class="title class_">Boolean</span>); <span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;str&#x27;</span> <span class="keyword">instanceof</span> <span class="title class_">String</span>); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([] <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Function</span>); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Object</span>);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>实现原理：instanceof用于判断构造函数的prototype属性是否出现在对象的原型链中的任何位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myInstanceof</span>(<span class="params">left, right</span>) &#123; <span class="comment">//left:对象，right构造函数</span></span><br><span class="line">    <span class="comment">//获取对象的原型</span></span><br><span class="line">    <span class="keyword">let</span> proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(left);</span><br><span class="line">    <span class="comment">//获取构造函数的prototype对象</span></span><br><span class="line">    <span class="keyword">let</span> prototype = right.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断构造函数的prototype对象是否在对象的原型链上</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!proto) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(proto === prototype) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//如果没有找到，就继续从其原型上找，Object.getPrototypeOf方法用来获取指定对象的原型</span></span><br><span class="line">        proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(proto);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//报错提示：Javascript错误提示--SyntaxError: Illegal return statement</span></span><br><span class="line"><span class="comment">//表示js的return语句只能放在function中，否则就会报错。</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>constructor</strong></li>
</ul>
<p><code>constructor</code>有2个作用：一个是判断数据的类型，二是对象示例通过<code>constructor</code>对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，<code>constructor</code>就不能用来判断数据类型了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="number">2</span>).<span class="property">constructor</span> === <span class="title class_">Number</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="literal">true</span>).<span class="property">constructor</span> === <span class="title class_">Boolean</span>); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="string">&#x27;str&#x27;</span>).<span class="property">constructor</span> === <span class="title class_">String</span>); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(([]).<span class="property">constructor</span> === <span class="title class_">Array</span>); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;).<span class="property">constructor</span> === <span class="title class_">Function</span>); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((&#123;&#125;).<span class="property">constructor</span> === <span class="title class_">Object</span>);  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"><span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="title class_">Fn</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="property">constructor</span>===<span class="title class_">Fn</span>);    <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="property">constructor</span>===<span class="title class_">Array</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Object.prototype.toString.call()</strong></li>
</ul>
<p><code>Object.prototype.toString.call()</code>是通过Object对象原型方法toString来判断数据类型。</p>
<p><code>obj.toString()</code>的结果和<code>Object.prototype.toString.call(obj)</code>的结果不一样：toString是Object的原型方法，而Array、Function等类型作为Object的实例，都重写了toString方法。不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的重写之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串…)，而不会去调用Object原型上的toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型；因此，在想要得到对象具体的类型应调用Object原型上的toString方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(<span class="number">2</span>)); <span class="comment">//[object Number]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(<span class="literal">true</span>)); <span class="comment">//[object Boolean]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(<span class="string">&#x27;str&#x27;</span>)); <span class="comment">//[object String]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>([])); <span class="comment">//[object Array]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;)); <span class="comment">//[object Function]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(&#123;&#125;)); <span class="comment">//[object Object]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(<span class="literal">undefined</span>)); <span class="comment">//[object Undefined]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(<span class="literal">null</span>)); <span class="comment">//[object Null]</span></span><br></pre></td></tr></table></figure>

<h4 id="判断数组方式（5种）"><a href="#判断数组方式（5种）" class="headerlink" title="判断数组方式（5种）"></a>判断数组方式（5种）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过Object.prototype.toString.call()判断</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj) == <span class="string">&quot;[object Array]&quot;</span>; <span class="comment">//true或者false</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>) == <span class="string">&quot;Array&quot;</span>; <span class="comment">//true或者false，其中slice(8, -1)截取其中的Array字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过instanceof做判断</span></span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="title class_">Array</span>; <span class="comment">//true或者false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过原型链做判断</span></span><br><span class="line">obj.<span class="property">__proto__</span> === <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">//true或者false</span></span><br><span class="line">obj.<span class="property">constructor</span> === <span class="title class_">Array</span>; <span class="comment">//true或者false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过ES6的Array.isArray()做判断</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj); <span class="comment">//true或者false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Array.prototype.isPrototypeOf</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(obj); <span class="comment">//true或者false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="数组的遍历方法（10种）"><a href="#数组的遍历方法（10种）" class="headerlink" title="数组的遍历方法（10种）"></a>数组的遍历方法（10种）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// forEach()：数组方法，不改变原数组，没有返回值</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(currentValue == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(currentValue, index, arr, <span class="variable language_">this</span>) </span><br><span class="line">&#125;, &#123;<span class="attr">a</span>: <span class="number">123</span>&#125;) <span class="comment">//&#123;a:123&#125;是改变指向this的值</span></span><br><span class="line"><span class="comment">//输出如下：</span></span><br><span class="line"><span class="comment">//1 0 [1, 2, 3] &#123;a: 123&#125;</span></span><br><span class="line"><span class="comment">//3 2 [1, 2, 3] &#123;a: 123&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//map()：数组方法，不改变原数组，有返回值，可链式调用</span></span><br><span class="line"><span class="keyword">var</span> doubles = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(currentValue, index, arr, <span class="variable language_">this</span>)</span><br><span class="line">    <span class="keyword">return</span> currentValue * <span class="number">2</span></span><br><span class="line">&#125;, &#123;<span class="attr">a</span>: <span class="number">123</span>&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(doubles)</span><br><span class="line"><span class="comment">//输出如下：</span></span><br><span class="line"><span class="comment">//1 0 [1, 2, 3] &#123;a: 123&#125;</span></span><br><span class="line"><span class="comment">//2 1 [1, 2, 3] &#123;a: 123&#125;</span></span><br><span class="line"><span class="comment">//3 2 [1, 2, 3] &#123;a: 123&#125;</span></span><br><span class="line"><span class="comment">//[2, 4, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//filter()：数组方法，过滤数组，返回包含符合条件的元素的数组，可链式调用</span></span><br><span class="line"><span class="keyword">var</span> doubles = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(currentValue, index, arr, <span class="variable language_">this</span>)</span><br><span class="line">    <span class="keyword">return</span> currentValue &gt;= <span class="number">2</span>;</span><br><span class="line">&#125;, &#123;<span class="attr">a</span>: <span class="number">123</span>&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(doubles)</span><br><span class="line"><span class="comment">//输出如下：</span></span><br><span class="line"><span class="comment">//1 0 [1, 2, 3] &#123;a: 123&#125;</span></span><br><span class="line"><span class="comment">//2 1 [1, 2, 3] &#123;a: 123&#125;</span></span><br><span class="line"><span class="comment">//3 2 [1, 2, 3] &#123;a: 123&#125;</span></span><br><span class="line"><span class="comment">//[2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//for...of：for...of遍历具有Iterator迭代器的对象的属性，返回的是数组的元素、对象的属性值，不能遍历普通的obj对象，将异步循环变成同步循环；遍历的是数组元素值（value）</span></span><br><span class="line"><span class="keyword">let</span> iterable = [<span class="number">30</span>, <span class="number">20</span>, <span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">    value += <span class="number">1</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出如下：</span></span><br><span class="line"><span class="comment">//31</span></span><br><span class="line"><span class="comment">//21</span></span><br><span class="line"><span class="comment">//11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//for...in： 遍历的是数组的索引（index），索引为字符串型数字，不能直接进行集合运算；更适合遍历对象。因此没算在遍历方法中</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = index + <span class="number">1</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出如下：</span></span><br><span class="line"><span class="comment">//01</span></span><br><span class="line"><span class="comment">//11</span></span><br><span class="line"><span class="comment">//21</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = &#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(index)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出如下：</span></span><br><span class="line"><span class="comment">//a</span></span><br><span class="line"><span class="comment">//b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//every()：只要有一个是false，便返回false</span></span><br><span class="line"><span class="keyword">const</span> numberFlag = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">every</span>(<span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(currentValue, index, arr, <span class="variable language_">this</span>)</span><br><span class="line">	<span class="keyword">return</span> currentValue &lt; <span class="number">2</span>;</span><br><span class="line">&#125;, &#123;<span class="attr">a</span>: <span class="number">123</span>&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(numberFlag)</span><br><span class="line"><span class="comment">//输出如下：</span></span><br><span class="line"><span class="comment">//1 0 [1, 2, 3] &#123;a: 123&#125;</span></span><br><span class="line"><span class="comment">//2 1 [1, 2, 3] &#123;a: 123&#125;</span></span><br><span class="line"><span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//some()：只要有一个是true，便返回true</span></span><br><span class="line"><span class="keyword">const</span> numberFlag = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">some</span>(<span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(currentValue, index, arr, <span class="variable language_">this</span>)</span><br><span class="line">	<span class="keyword">return</span> currentValue &lt; <span class="number">23</span>;</span><br><span class="line">&#125;, &#123;<span class="attr">a</span>: <span class="number">123</span>&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(numberFlag)</span><br><span class="line"><span class="comment">//输出如下：</span></span><br><span class="line"><span class="comment">//1 0 [1, 2, 3] &#123;a: 123&#125;</span></span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//find()：返回的是第一个符合条件的值</span></span><br><span class="line"><span class="keyword">const</span> numberFlag = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">find</span>(<span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(currentValue, index, arr, <span class="variable language_">this</span>)</span><br><span class="line">	<span class="keyword">return</span> currentValue &lt; <span class="number">3</span>;</span><br><span class="line">&#125;, &#123;<span class="attr">a</span>: <span class="number">123</span>&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(numberFlag)</span><br><span class="line"><span class="comment">//输出如下：</span></span><br><span class="line"><span class="comment">//1 0 [1, 2, 3] &#123;a: 123&#125;</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//findIndex()：返回的是第一个返回条件的值的索引值</span></span><br><span class="line"><span class="keyword">const</span> numberFlag = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">findIndex</span>(<span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(currentValue, index, arr, <span class="variable language_">this</span>)</span><br><span class="line">	<span class="keyword">return</span> currentValue &lt; <span class="number">3</span>;</span><br><span class="line">&#125;, &#123;<span class="attr">a</span>: <span class="number">123</span>&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(numberFlag)</span><br><span class="line"><span class="comment">//输出如下：</span></span><br><span class="line"><span class="comment">//1 0 [1, 2, 3] &#123;a: 123&#125;</span></span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//reduce()：对数组正序操作</span></span><br><span class="line"><span class="keyword">const</span> number = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">reduce</span>(<span class="keyword">function</span>(<span class="params">total, currentValue, currentIndex, arr</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(total, currentValue, currentIndex, arr, <span class="variable language_">this</span>)</span><br><span class="line">	<span class="keyword">return</span> total + currentValue;</span><br><span class="line">&#125;, <span class="number">150</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(number)</span><br><span class="line"><span class="comment">//输出如下：</span></span><br><span class="line"><span class="comment">//150 1 0 [1, 2, 3] Window &#123;window: Window, self: Window, document: document, name: &#x27;&#x27;, location: Location, …&#125;</span></span><br><span class="line"><span class="comment">//151 2 1 [1, 2, 3] Window &#123;window: Window, self: Window, document: document, name: &#x27;&#x27;, location: Location, …&#125;</span></span><br><span class="line"><span class="comment">//153 3 2 [1, 2, 3] Window &#123;window: Window, self: Window, document: document, name: &#x27;&#x27;, location: Location, …&#125;</span></span><br><span class="line"><span class="comment">//156</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//reduceRight()：reduceRight()对数组逆序操作</span></span><br><span class="line"><span class="keyword">const</span> number = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">reduceRight</span>(<span class="keyword">function</span>(<span class="params">total, currentValue, currentIndex, arr</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(total, currentValue, currentIndex, arr, <span class="variable language_">this</span>)</span><br><span class="line">	<span class="keyword">return</span> total + currentValue;</span><br><span class="line">&#125;, <span class="number">150</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(number)</span><br><span class="line"><span class="comment">//输出如下：</span></span><br><span class="line"><span class="comment">//150 3 2 [1, 2, 3] Window &#123;window: Window, self: Window, document: document, name: &#x27;&#x27;, location: Location, …&#125;</span></span><br><span class="line"><span class="comment">//153 2 1 [1, 2, 3] Window &#123;window: Window, self: Window, document: document, name: &#x27;&#x27;, location: Location, …&#125;</span></span><br><span class="line"><span class="comment">//155 1 0 [1, 2, 3] Window &#123;window: Window, self: Window, document: document, name: &#x27;&#x27;, location: Location, …&#125;</span></span><br><span class="line"><span class="comment">//156</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="基础（操作符new-x2F-隐式转换）"><a href="#基础（操作符new-x2F-隐式转换）" class="headerlink" title="基础（操作符new&#x2F;隐式转换）"></a>基础（操作符new&#x2F;隐式转换）</h2><h3 id="隐式转换规则"><a href="#隐式转换规则" class="headerlink" title="隐式转换规则"></a>隐式转换规则</h3><p>当隐式转换为number时，在ToPrimitive中优先查找obj的valueOf方法，如果为原始值，则返回，否则调用obj的toString方法，如果为原始值则返回，否则抛出TypeError异常。</p>
<p>当隐式转换为string时，在ToPrimitive中优先查找toString方法，如果为原始值则返回，否则调用obj的valueOf方法，如果有原始值则返回，否则抛出TypeError异常。</p>
<p>如果对象为Date，默认转化为string，其他情况下默认number。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// + 操作符：如果有string，优先string类型，其他情况下两边会被转换number</span></span><br><span class="line"><span class="number">1</span>+<span class="string">&#x27;23&#x27;</span> <span class="comment">//&#x27;123&#x27;</span></span><br><span class="line"><span class="number">1</span>+<span class="literal">false</span> <span class="comment">//1</span></span><br><span class="line"><span class="number">1</span>+<span class="title class_">Symbol</span>() <span class="comment">//Uncaught TypeError: Cannot convert a Symbol value to a number</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span>+<span class="literal">false</span> <span class="comment">//1false</span></span><br><span class="line"><span class="literal">false</span>+<span class="literal">true</span> <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -、*、/ 操作符：默认转化为number，NaN也是数字类型</span></span><br><span class="line"><span class="number">1</span>*<span class="string">&#x27;23&#x27;</span> <span class="comment">//23</span></span><br><span class="line"><span class="number">1</span>*<span class="literal">false</span> <span class="comment">//0</span></span><br><span class="line"><span class="number">1</span> / <span class="string">&#x27;aa&#x27;</span> <span class="comment">//NaN</span></span><br><span class="line"><span class="number">1</span>/<span class="number">0</span> <span class="comment">//Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// == 操作符：两遍都尽量转换成number</span></span><br><span class="line"><span class="number">3</span> == <span class="literal">true</span> <span class="comment">//false, 3转化为number为3，true转化为number为1</span></span><br><span class="line"><span class="string">&#x27;0&#x27;</span> == <span class="literal">false</span> <span class="comment">//true, &#x27;0&#x27;转化为number为0，false转化为number为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &gt; 和 &lt; 比较符：都是字符串，字母按照字母表顺序比较，其他转化为数字</span></span><br><span class="line"><span class="string">&#x27;a&#x27;</span> &lt; <span class="string">&#x27;b&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;a&#x27;</span> &lt; <span class="string">&#x27;b&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> &gt; -<span class="number">1</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;a &gt; <span class="number">2</span> <span class="comment">// false </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">过程解释：</span></span><br><span class="line"><span class="comment">a.valueOf() // &#123;&#125;, 上面提到过，ToPrimitive默认type为number，所以先valueOf，结果还是个对象，下一步</span></span><br><span class="line"><span class="comment">a.toString() // &quot;[object Object]&quot;，现在是一个字符串了</span></span><br><span class="line"><span class="comment">Number(a.toString()) // NaN，根据上面 &lt; 和 &gt; 操作符的规则，要转换成数字</span></span><br><span class="line"><span class="comment">NaN &gt; 2 //false，得出比较结果</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="操作符new"><a href="#操作符new" class="headerlink" title="操作符new"></a>操作符new</h3><p>new操作符的执行过程：</p>
<p>1、创建一个新的空对象；</p>
<p>2、设置原型，将对象的原型设置为函数的prototype对象；</p>
<p>3、让函数的this指向这个对象，执行构造函数的代码（为这个新对象添加属性）；</p>
<p>4、判断函数的返回值类型，如果是值类型，返回创建对象；如果是引用类型，返回引用类型的对象。</p>
<p>小提示：箭头函数是无法new的，因为它没有prototype，也没有自己的this指向，更不可能有arguments参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">objectFactory</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> constructor = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">shift</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 判断参数是否是一个函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> constructor !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;type error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 新建一个空对象，对象的原型为构造函数的 prototype 对象</span></span><br><span class="line">  newObject = <span class="title class_">Object</span>.<span class="title function_">create</span>(constructor.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  <span class="comment">// 将 this 指向新建对象，并执行函数</span></span><br><span class="line">  result = constructor.<span class="title function_">apply</span>(newObject, <span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="comment">// 判断返回对象</span></span><br><span class="line">  <span class="keyword">let</span> flag = result &amp;&amp; (<span class="keyword">typeof</span> result === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> result === <span class="string">&quot;function&quot;</span>);</span><br><span class="line">  <span class="comment">// 判断返回结果</span></span><br><span class="line">  <span class="keyword">return</span> flag ? result : newObject;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line"><span class="title function_">objectFactory</span>(构造函数, 初始化参数);</span><br></pre></td></tr></table></figure>

<h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><p>js内置对象主要指的是在程序执行前存在全局作用域里的由js定义的一些全局值属性、函数和用来实例化其他对象的构造函数对象。</p>
<p>值属性（全局属性返回一个简单值）: undefined、null、Infinity、NaN字面量等；</p>
<p>函数属性（不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者）：eval()、parseInt()、parseFloat()等；</p>
<p>基本对象（是定义或调用其他对象的基础，一般包括对象、函数对象和错误对象）：Object、Function、Boolean、Symbol、Error等；</p>
<p>数字和日期对象（数字、日期对象和执行数学计算的对象）：Number、Math、Date等；</p>
<p>字符串（用来表示和字符串操作的对象）：String、RegExp等；</p>
<p>可索引的集合对象（表示按照索引值类排序的数据集合，包括数组和类型数组，以及类数组结构的对象）：Array等；</p>
<p>使用键的集合对象（集合在存储数据时会使用到键，支持按照插入顺序来迭代元素）：Map、Set、WeakMap、WeakSet等；</p>
<p>矢量集合：SIMD等；</p>
<p>结构化数据：JSON等；</p>
<p>控制抽象对象：Promise、Generator等；</p>
<p>反射：Proxy、Reflect等</p>
<p>国际化（支持多语言）：Intl、Intl.Collator等；</p>
<p>WebAssembly：</p>
<p>其他：例如 arguments</p>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p><strong>常见的位运算符</strong>:&amp;(与：两个位都为1时，结果才为1)、|（或）、^（异或：两个位相同为0，相异为1）、~（取反：0变1，1变0）、&lt;&lt;（左移：各二进制位全部左移若干位，高位丢弃，低位补0）、&gt;&gt;（右移：各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃）；</p>
<p><strong>运算规则：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&amp; </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用途:</span></span><br><span class="line"><span class="comment">判断奇偶:只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用 if ((i &amp; 1) == 0)代替 if (i % 2 == 0)来判断a是不是偶数。</span></span><br><span class="line"><span class="comment">清零:如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="number">0</span> &amp; <span class="number">0</span> <span class="comment">//0</span></span><br><span class="line"><span class="number">0</span> &amp; <span class="number">1</span> <span class="comment">//0</span></span><br><span class="line"><span class="number">1</span> &amp; <span class="number">1</span> <span class="comment">//1</span></span><br><span class="line"><span class="number">1</span> &amp; <span class="number">0</span> <span class="comment">//0</span></span><br><span class="line"><span class="number">3</span> &amp; <span class="number">5</span> <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// |</span></span><br><span class="line"><span class="number">0</span> | <span class="number">0</span> <span class="comment">// 0</span></span><br><span class="line"><span class="number">0</span> | <span class="number">1</span> <span class="comment">// 1  </span></span><br><span class="line"><span class="number">1</span> | <span class="number">0</span> <span class="comment">// 1  </span></span><br><span class="line"><span class="number">1</span> | <span class="number">1</span> <span class="comment">// 1</span></span><br><span class="line"><span class="number">3</span> | <span class="number">5</span> <span class="comment">//7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ^</span></span><br><span class="line"><span class="number">0</span> ^ <span class="number">0</span> <span class="comment">// 0  </span></span><br><span class="line"><span class="number">0</span> ^ <span class="number">1</span> <span class="comment">// 1  </span></span><br><span class="line"><span class="number">1</span> ^ <span class="number">0</span> <span class="comment">// 1  </span></span><br><span class="line"><span class="number">1</span> ^ <span class="number">1</span> <span class="comment">// 0</span></span><br><span class="line"><span class="number">3</span> ^ <span class="number">5</span> <span class="comment">//7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ~</span></span><br><span class="line">~ <span class="number">1</span> <span class="comment">// 0</span></span><br><span class="line">~ <span class="number">0</span> <span class="comment">// 1</span></span><br><span class="line">~ <span class="number">5</span> <span class="comment">//-6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;&lt;</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">设 a=1010 1110，a = a&lt;&lt; 2 将a的二进制位左移2位、右补0，即得a=1011 1000。</span></span><br><span class="line"><span class="comment">若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="number">1</span>&gt;&gt;<span class="number">2</span> <span class="comment">//0</span></span><br><span class="line"><span class="number">2</span>&gt;&gt;<span class="number">2</span> <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &gt;&gt; </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">定义： 将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。</span></span><br><span class="line"><span class="comment">定义： 将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="number">10</span> &gt;&gt; <span class="number">2</span> <span class="comment">//2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="原码、补码、反码"><a href="#原码、补码、反码" class="headerlink" title="原码、补码、反码"></a>原码、补码、反码</h3><p>计算机中的<strong>有符号数</strong>有三种表示方法，即原码、反码和补码。三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位，三种表示方法各不相同.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原码:原码就是一个数的二进制数。</span></span><br><span class="line"><span class="comment">//例如：10的原码为0000 1010</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//反码</span></span><br><span class="line"><span class="comment">//正数的反码与原码相同，如：10 反码为 0000 1010</span></span><br><span class="line"><span class="comment">//负数的反码为除符号位，按位取反，即0变1，1变0。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例如：-10</span></span><br><span class="line">原码：<span class="number">1000</span> <span class="number">1010</span></span><br><span class="line">反码：<span class="number">1111</span> <span class="number">0101</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//补码</span></span><br><span class="line"><span class="comment">//正数的补码与原码相同，如：10 补码为 0000 1010</span></span><br><span class="line"><span class="comment">//负数的补码是原码除符号位外的所有位取反即0变1，1变0，然后加1，也就是反码加1。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例如：-10</span></span><br><span class="line">原码：<span class="number">1000</span> <span class="number">1010</span></span><br><span class="line">反码：<span class="number">1111</span> <span class="number">0101</span></span><br><span class="line">补码：<span class="number">1111</span> <span class="number">0110</span></span><br></pre></td></tr></table></figure>





<h2 id="作用域-x2F-执行上下文-x2F-闭包"><a href="#作用域-x2F-执行上下文-x2F-闭包" class="headerlink" title="作用域&#x2F;执行上下文&#x2F;闭包"></a>作用域&#x2F;执行上下文&#x2F;闭包</h2><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>指的是有权访问另一个函数作用域中的变量的函数。</p>
<p>创建闭包的最常见的方式是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。</p>
<p>闭包有两个常用的用途：一是使我们在函数外部能够访问到函数内部的变量；二是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">B</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">A</span>()</span><br><span class="line"><span class="title function_">B</span>() <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*循环中使用闭包解决 var 定义函数的问题*/</span></span><br><span class="line"><span class="comment">//立即执行函数(使用闭包的方式)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    (<span class="keyword">function</span> (<span class="params">j</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(j)</span><br><span class="line">        &#125;, j * <span class="number">1000</span>)</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用 setTimeout 的第三个参数，这个参数会被当成 timer函数的参数传入</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params">j</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(j)</span><br><span class="line">    &#125;, i * <span class="number">1000</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用 let 定义 i 了来解决问题了，这个也是最为推荐的方式</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="作用域-x2F-作用域链"><a href="#作用域-x2F-作用域链" class="headerlink" title="作用域&#x2F;作用域链"></a>作用域&#x2F;作用域链</h3><p><strong>全局作用域</strong>：最外层函数和最外层函数外面定义的变量拥有全局作用域，所有未定义直接赋值的变量自动声明为全局作用域，所有window对象的属性拥有全局作用域，所有window对象的属性拥有全局作用域；</p>
<p><strong>函数作用域</strong>：函数作用域声明在函数内部的变零，一般只有固定的代码片段可以访问到，作用域是分层的，内层作用域可以访问外层作用域，反之不行。</p>
<p><strong>块级作用域</strong>：使用ES6中新增的let和const指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由 <code>&#123; &#125;</code>包裹的代码片段），使用ES6中新增的let和const指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由 <code>&#123; &#125;</code>包裹的代码片段），在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。</p>
<p><strong>作用域链</strong>：在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。</p>
<p>作用域链的作用是<strong>保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。</strong>作用域链的本质上是一个指向变量对象的指针列表。</p>
<h3 id="对执行上下文的理解"><a href="#对执行上下文的理解" class="headerlink" title="对执行上下文的理解"></a>对执行上下文的理解</h3><p><strong>全局执行上下文</strong>：任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的window对象，并且设置this的值等于这个全局对象，一个程序中只有一个全局执行上下文；</p>
<p><strong>函数执行上下文</strong>：当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个；</p>
<p><code>eval</code><strong>函数执行上下文</strong>：执行在eval函数中的代码会有属于他自己的执行上下文，不过eval函数不常使用。</p>
<h3 id="this-x2F-call-x2F-apply-x2F-bind"><a href="#this-x2F-call-x2F-apply-x2F-bind" class="headerlink" title="this&#x2F;call&#x2F;apply&#x2F;bind"></a>this&#x2F;call&#x2F;apply&#x2F;bind</h3><h4 id="对this对象的理解"><a href="#对this对象的理解" class="headerlink" title="对this对象的理解"></a><strong>对this对象的理解</strong></h4><p>this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。</p>
<p>在实际开发中，this 的指向可以通过四种调用模式来判断：<strong>函数调用模式</strong>（当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象）；<strong>方法调用模式</strong>（如果一个函数作为一个对象的方法来调用时，this 指向这个对象）；<strong>构造器调用模式</strong>（如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象）；<strong>apply 、 call 和 bind 调用模式</strong>（这三个方法都可以显示的指定调用函数的 this 指向）</p>
<p>call() 和 apply() 的区别：apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数；call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。</p>
<h4 id="call-函数的实现步骤"><a href="#call-函数的实现步骤" class="headerlink" title="call 函数的实现步骤"></a><strong>call 函数的实现步骤</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</span><br><span class="line"><span class="number">2</span>、判断传入上下文对象是否存在，如果不存在，则设置为 <span class="variable language_">window</span> 。</span><br><span class="line"><span class="number">3</span>、处理传入的参数，截取第一个参数后的所有参数。</span><br><span class="line"><span class="number">4</span>、将函数作为上下文对象的一个属性。</span><br><span class="line"><span class="number">5</span>、使用上下文对象来调用这个方法，并保存返回结果。</span><br><span class="line"><span class="number">6</span>、删除刚才新增的属性。</span><br><span class="line"><span class="number">7</span>、返回结果。</span><br><span class="line"></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断调用对象</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;type error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取参数</span></span><br><span class="line">  <span class="keyword">let</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>),</span><br><span class="line">    result = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 判断 context 是否传入，如果未传入则设置为 window</span></span><br><span class="line">  context = context || <span class="variable language_">window</span>;</span><br><span class="line">  <span class="comment">// 将调用函数设为对象的方法</span></span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="comment">// 调用函数</span></span><br><span class="line">  result = context.<span class="title function_">fn</span>(...args);</span><br><span class="line">  <span class="comment">// 将属性删除</span></span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="apply-函数的实现步骤"><a href="#apply-函数的实现步骤" class="headerlink" title="apply 函数的实现步骤"></a><strong>apply 函数的实现步骤</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</span><br><span class="line"><span class="number">2</span>、判断传入上下文对象是否存在，如果不存在，则设置为 <span class="variable language_">window</span> 。</span><br><span class="line"><span class="number">3</span>、将函数作为上下文对象的一个属性。</span><br><span class="line"><span class="number">4</span>、判断参数值是否传入</span><br><span class="line"><span class="number">5</span>、使用上下文对象来调用这个方法，并保存返回结果。</span><br><span class="line"><span class="number">6</span>、删除刚才新增的属性</span><br><span class="line"><span class="number">7</span>、返回结果</span><br><span class="line"></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 判断 context 是否存在，如果未传入则为 window</span></span><br><span class="line">  context = context || <span class="variable language_">window</span>;</span><br><span class="line">  <span class="comment">// 将函数设为对象的方法</span></span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="comment">// 调用方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">    result = context.<span class="title function_">fn</span>(...<span class="variable language_">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context.<span class="title function_">fn</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将属性删除</span></span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="bind-函数的实现步骤"><a href="#bind-函数的实现步骤" class="headerlink" title="bind 函数的实现步骤"></a><strong>bind 函数的实现步骤</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</span><br><span class="line"><span class="number">2</span>、保存当前函数的引用，获取其余传入参数值。</span><br><span class="line"><span class="number">3</span>、创建一个函数返回</span><br><span class="line"><span class="number">4</span>、函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 <span class="variable language_">this</span> 给 apply 调用，其余情况都传入指定的上下文对象。</span><br><span class="line"></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;err&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">let</span> fn = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">const</span> func = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span> <span class="keyword">instanceof</span> fn ? <span class="attr">this</span>:context, args.<span class="title function_">concat</span>([...<span class="variable language_">arguments</span>]))</span><br><span class="line">  &#125;</span><br><span class="line">  func.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(fn.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line">  func.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = func</span><br><span class="line">  <span class="keyword">return</span> func</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="原型-x2F-原型链-x2F-继承"><a href="#原型-x2F-原型链-x2F-继承" class="headerlink" title="原型&#x2F;原型链&#x2F;继承"></a>原型&#x2F;原型链&#x2F;继承</h2><p>原型：当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。</p>
<p>原型链：当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。（原型链的尽头一般来说都是 Object.prototype ）。</p>
<p>继承指的是对象的继承，指的是子对象能够使用父级对象的事件。</p>
<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>1、JavaScript是单线程，非阻塞的。</p>
<p>2、浏览器事件循环：执行栈和事件队列；宏任务（macrotask）和微任务（microtask）。</p>
<p>宏任务：script(整体代码)、setTimeout()、setInterval()、postMessage、I&#x2F;O、UI交互事件、MessageChannel、setImmediate(Node.js 环境)；</p>
<p>微任务：new Promise().then(回调)、MutationObserver(html5 新特性)、Object.observe、process.nextTick(Node.js 环境)。</p>
<p>在事件循环中，每进行一次循环操作称为 tick，每一次 tick 的任务处理模型是比较复杂的。</p>
<p>运行顺序：执行一个宏任务（栈中没有就从事件队列中获取）；执行过程中如果遇到微任务，就将它添加到微任务的任务队列中；宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）；当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染；渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）。</p>
<p>执行宏任务，然后执行该宏任务产生的微任务，若微任务在执行过程中产生了新的微任务，则继续执行微任务，微任务执行完毕后，再回到宏任务中进行下一轮循环。</p>
<p>3、node环境下的事件循环：表现出的状态与浏览器大致相同。不同的是 node 中有一套自己的模型。node 中事件循环的实现依赖 libuv 引擎。Node的事件循环存在几个阶段（如果是node10及其之前版本，microtask会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行 microtask队列中的任务；node版本更新到11之后，Event Loop运行原理发生了变化，一旦执行一个阶段里的一个宏任务(setTimeout,setInterval和setImmediate)就立刻执行微任务队列，跟浏览器趋于一致。</p>
<h2 id="异步编程-x2F-Promise-x2F-async和await-x2F-并发-x2F-并行"><a href="#异步编程-x2F-Promise-x2F-async和await-x2F-并发-x2F-并行" class="headerlink" title="异步编程&#x2F;Promise&#x2F;async和await&#x2F;并发&#x2F;并行"></a>异步编程&#x2F;Promise&#x2F;async和await&#x2F;并发&#x2F;并行</h2><h3 id="JavaScript中的异步机制"><a href="#JavaScript中的异步机制" class="headerlink" title="JavaScript中的异步机制"></a>JavaScript中的异步机制</h3><p>可以分为以下几种：</p>
<p><strong>回调函数</strong> 的方式（使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护）；</p>
<p><strong>Promise</strong> 的方式（使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确）；</p>
<p><strong>generator</strong> 的方式（它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来）；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">function</span>* <span class="title function_">generatorForLoop</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; num; i += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(i, <span class="string">&quot;generator&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> genForLoop = <span class="title function_">generatorForLoop</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">genForLoop.<span class="title function_">next</span>(); <span class="comment">// 首先 console.log —— 0</span></span><br><span class="line">genForLoop.<span class="title function_">next</span>(); <span class="comment">// 1</span></span><br><span class="line">genForLoop.<span class="title function_">next</span>(); <span class="comment">// 2</span></span><br><span class="line">genForLoop.<span class="title function_">next</span>(); <span class="comment">// 3</span></span><br><span class="line">genForLoop.<span class="title function_">next</span>(); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p><strong>async 函数</strong> 的方式(async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行)。</p>
<h3 id="setTimeout、Promise、Async-x2F-Await-的区别"><a href="#setTimeout、Promise、Async-x2F-Await-的区别" class="headerlink" title="setTimeout、Promise、Async&#x2F;Await 的区别"></a>setTimeout、Promise、Async&#x2F;Await 的区别</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//setTimeout</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>) <span class="comment">//1. 打印 script start</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;settimeout&#x27;</span>)   <span class="comment">// 4. 打印 settimeout</span></span><br><span class="line">&#125;)  <span class="comment">// 2. 调用 setTimeout 函数，并定义其完成后执行的回调函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>)   <span class="comment">//3. 打印 script start</span></span><br><span class="line"><span class="comment">// 输出顺序：script start-&gt;script end-&gt;settimeout</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Promise:Promise本身是同步的立即执行函数， 当在executor中执行resolve或者reject的时候, 此时是异步操作， 会先执行then/catch等，当主栈完成后，才会去调用resolve/reject中存放的方法执行，打印p的时候，是打印的返回结果，一个Promise实例。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1 end&#x27;</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;settimeout&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"><span class="comment">// 输出顺序: script start-&gt;promise1-&gt;promise1 end-&gt;script end-&gt;promise2-&gt;settimeout</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//async/await</span></span><br><span class="line"><span class="comment">//async/await其实是 Generator 的语法糖，能实现的效果都能用then链来实现（它是为优化then链而开发出来的）</span></span><br><span class="line"><span class="comment">//async 返回的是一个Promise对象</span></span><br><span class="line"><span class="comment">//await 等待的如果不是一个Promise对象，那运算结果就是它等到的东西，如果是promise对象，那等的就是resolve得到的值</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 start&#x27;</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">async2</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"><span class="title function_">async1</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"><span class="comment">// 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//async/await 相对promise的优势</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Promise传递中间值⾮常麻烦，⽽async/await⼏乎是同步的写法，⾮常优雅</span></span><br><span class="line"><span class="comment">错误处理友好，async/await可以⽤成熟的try/catch，Promise的错误捕获⾮常冗余</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="对Promise的理解"><a href="#对Promise的理解" class="headerlink" title="对Promise的理解"></a>对Promise的理解</h3><p>Promise的实例有<strong>三个状态</strong>：Pending（进行中）、Resolved（已完成）、Rejected（已拒绝）。</p>
<p>优点：对象的状态不受外界影响，一旦状态改变就不会再变，任何时候都可以得到这个结果。</p>
<p>缺点：无法取消Promise，一旦新建它就会立即执行，无法中途取消。无法取消Promise，一旦新建它就会立即执行，无法中途取消。当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>
<p>Promise有五个常用的方法：then()、catch()、all()、race()、finally。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">// resolve(&#123; success: &quot;成功&quot; &#125;, &#123; success: &quot;成功2号&quot; &#125;)</span></span><br><span class="line">    <span class="title function_">reject</span>(&#123; <span class="attr">error</span>: <span class="string">&quot;失败&quot;</span> &#125;);</span><br><span class="line">    <span class="comment">//resolve和reject同时存在的时候，只有resolve有效果，也就是then有返回。</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(&#123; <span class="attr">success</span>: <span class="string">&quot;成功+++1&quot;</span> &#125;)</span><br><span class="line">    <span class="comment">// reject(&#123; error: &quot;失败+++1&quot; &#125;);</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> promise3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">// resolve(&#123; success: &quot;成功~~~~~1&quot; &#125;)</span></span><br><span class="line">    <span class="title function_">reject</span>(&#123; <span class="attr">error</span>: <span class="string">&quot;失败~~~~~1&quot;</span> &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//then()</span></span><br><span class="line">promise1.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123; <span class="comment">//这个和catch都有的时候执行这个函数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123; <span class="comment">//then没有第二个函数的时候执行catch（catch方法还有一个作用，就是在执行 resolve回调函数时，如果出现错误，抛出异常，不会停止运行，而是进入 catch方法中）</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error, <span class="string">&quot;第二次失败&quot;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//all()</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([promise1,promise2,promise3]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);  <span class="comment">//全部resolve才会返回，否则全部在异常里面返回</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error); <span class="comment">//只要有一个失败就在这里返回</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//race()：是赛跑的意思，只返最先执行完的那个状态，成功返回resolved，失败返回rejected</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([promise1, promise2, promise3]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res, <span class="string">&quot;race&quot;</span>);</span><br><span class="line">&#125;, <span class="function"><span class="params">rej</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(rej, <span class="string">&quot;race&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//finally()：不依赖于 Promise 的执行结果，也就是resolved和rejected都会执行，且只执行1次。</span></span><br></pre></td></tr></table></figure>



<h3 id="并发与并行的区别"><a href="#并发与并行的区别" class="headerlink" title="并发与并行的区别"></a>并发与并行的区别</h3><p><strong>并发</strong>是宏观概念，我分别有任务 A 和任务 B，在一段时间内通过任务间的切换完成了这两个任务，这种情况就可以称之为并发。</p>
<p><strong>并行</strong>是微观概念，假设 CPU 中存在两个核心，那么我就可以同时完成任务 A、B。同时完成多个任务的情况就可以称之为并行。</p>
<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>Proxy 是 ES6 中新增的功能，它可以用来自定义对象中的操作。</p>
<p>new Proxy(target, handler)：target为需要代理的对象，handler传的是具体的get、set方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">watchProxy</span> = (<span class="params">obj</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params">target, property, receiver</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(target, property, receiver, <span class="string">&quot;get-watch&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, property, receiver); <span class="comment">//返回对象的属性</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">target, property, value, receiver</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(target, property, value, receiver, <span class="string">&quot;set-watch&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, property, value, receiver); <span class="comment">//设置对象的属性</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="title function_">watchProxy</span>(obj);</span><br><span class="line">p1.<span class="property">a</span> = <span class="string">&quot;重新测试&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1, p1.<span class="property">a</span>);</span><br></pre></td></tr></table></figure>



<h2 id="ES6新特性（常用方法区别）"><a href="#ES6新特性（常用方法区别）" class="headerlink" title="ES6新特性（常用方法区别）"></a>ES6新特性（常用方法区别）</h2><p>1、<strong>let、const、var：</strong> <em>块级作用域</em>（let、const有；var没有）、<em>存在变量提升</em>（var有变量提升；let、const没有，即在变量只能在声明之后使用，否在会报错）、<em>添加全局属性</em>（var声明的变量为全局，<strong>：</strong>浏览器的全局对象是window，Node的全局对象是global）、<em>重复声明</em>（const和let不允许重复声明变量；var可以重复声明，后声明的同名变量会覆盖之前声明的遍历）、<em>存在暂时性死区</em>（let、const命令声明变量之前，该变量都是不可用的；var声明的变量不存在暂时性死区）、<em>设置初始值</em>（var 和 let 可以不用设置初始值；const声明变量必须设置初始值）、<em>指针指向</em>（ let创建的变量是可以更改指针指向（可以重新赋值）；const声明的变量是不允许改变指针的指向）；</p>
<p>2、<strong>箭头函数与普通函数的区别</strong>：箭头函数比普通函数更加简洁；箭头函数比普通函数更加简洁；箭头函数继承来的this指向永远不会改变；call()、apply()、bind()等方法不能改变箭头函数中this的指向（），this是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值；箭头函数不能作为构造函数使用；箭头函数没有自己的arguments；箭头函数没有prototype；箭头函数不能用作Generator函数，不能使用yeild关键字。</p>
<p>3、<strong>扩展运算符（…）的作用及使用场景</strong>：对象扩展运算符（扩展运算符对对象实例的拷贝属于浅拷贝）、数组扩展运算符（数组的扩展运算符可以将一个数组转为用逗号分隔的参数序列，且每次只能展开一层数组）。</p>
<p>4、<strong>模板语法：</strong>在模板字符串中，空格、缩进、换行都会被保留；模板字符串完全支持“运算”式的表达式，可以在${}里完成一些计算。</p>
<p>5、<strong>Map</strong>：ES6提供的Map数据结构类似于对象，但是它的键不限制范围，可以是任意类型，是一种更加完善的Hash结构。实际上Map是一个数组，它的每一个数据也都是一个数组。（有以下操作方法：size、set(key,value)、get(key)、has(key)、delete(key)、clear()；遍历方法：keys()、values()、entries()、forEach()）。</p>
<p>6、<strong>模块Module</strong>：和CommonJS模块区别（CommonJS是对模块的浅拷⻉、ES6 Module是对模块的引⽤，即ES6 Module只存只读，不能改变其值，也就是指针指向不能变，类似const；import的接⼝是read-only（只读状态），不能修改其变量值）；和CommonJS模块的共同点（都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变；CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS 模块是运行时加载，ES6 模块是编译时输出接口；CommonJs 是单个值导出，ES6 Module可以导出多个；CommonJs 是动态语法可以写在判断里，ES6 Module 静态语法只能写在顶层；CommonJs 的 this 是当前模块，ES6 Module的 this 是 undefined）。</p>
<p>7、<strong>for…of遍历</strong>：ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，普通的对象用for..of遍历是会报错的。</p>
<p>8、<strong>Symbol 和 BigInt</strong> ：数据类型</p>
<h2 id="Ajax-x2F-fetch-x2F-axios-x2F-网络协议"><a href="#Ajax-x2F-fetch-x2F-axios-x2F-网络协议" class="headerlink" title="Ajax&#x2F;fetch&#x2F;axios&#x2F;网络协议"></a>Ajax&#x2F;fetch&#x2F;axios&#x2F;网络协议</h2><h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><p>AJAX是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的 异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。</p>
<p>缺陷：本身是针对MVC编程，不符合前端MVVM的浪潮；基于原生XHR开发，XHR本身的架构不清晰；不符合关注分离（Separation of Concerns）的原则；配置和调用方式非常混乱，而且基于事件的异步模型不友好。</p>
<p>创建AJAX请求的步骤：</p>
<ul>
<li><p><strong>创建一个 XMLHttpRequest 对象。</strong></p>
</li>
<li><p>在这个对象上<strong>使用 open 方法创建一个 HTTP 请求</strong>，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。</p>
</li>
<li><p>在发起请求前，可以为这个对象<strong>添加一些信息和监听函数</strong>。比如说可以通过 setRequestHeader 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 response 中的数据来对页面进行更新了。</p>
</li>
<li><p>当对象的属性和监听函数设置完成后，最后<strong>调用 sent 方法来向服务器发起请求</strong>，可以传入参数作为发送的数据体。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Promise封装AJAX：</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getJSON</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="comment">// 创建一个 promise 对象</span></span><br><span class="line">  <span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    <span class="comment">// 新建一个 http 请求</span></span><br><span class="line">    xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, url, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 设置状态的监听函数</span></span><br><span class="line">    xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> !== <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">      <span class="comment">// 当请求成功或失败时，改变 promise 的状态</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="variable language_">this</span>.<span class="property">response</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 设置错误监听函数</span></span><br><span class="line">    xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 设置响应的数据类型</span></span><br><span class="line">    xhr.<span class="property">responseType</span> = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">    <span class="comment">// 设置请求头信息</span></span><br><span class="line">    xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">    <span class="comment">// 发送 http 请求</span></span><br><span class="line">    xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h3><p>fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多。<strong>fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象</strong>。</p>
<p>优点：语法简洁，更加语义化；基于标准 Promise 实现，支持 async&#x2F;await；更加底层，提供的API丰富（request, response）；脱离了XHR，是ES规范里新的实现方式。</p>
<p>缺点：fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject；fetch默认不会带cookie，需要添加配置项： fetch(url, {credentials: ‘include’})；fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费；fetch没有办法原生监测请求的进度，而XHR可以。</p>
<h3 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h3><p>Axios 是一种基于Promise封装的HTTP客户端，其特点如下：</p>
<ul>
<li>浏览器端发起XMLHttpRequests请求</li>
<li>node端发起http请求</li>
<li>支持Promise API</li>
<li>监听请求和返回</li>
<li>对请求和返回进行转化</li>
<li>取消请求</li>
<li>自动转换json数据</li>
<li>客户端支持抵御XSRF攻击</li>
</ul>
<h2 id="垃圾回收与内存泄漏"><a href="#垃圾回收与内存泄漏" class="headerlink" title="垃圾回收与内存泄漏"></a>垃圾回收与内存泄漏</h2><h3 id="浏览器的垃圾回收机制"><a href="#浏览器的垃圾回收机制" class="headerlink" title="浏览器的垃圾回收机制"></a>浏览器的垃圾回收机制</h3><p><strong>概念</strong>：JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。</p>
<p><strong>回收机制</strong>：</p>
<p>Javascript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存；</p>
<p>JavaScript中存在两种变量：局部变量和全局变量。全局变量的生命周期会持续要页面卸载；而局部变量声明在函数中，它的生命周期从函数执行开始，直到函数执行结束，在这个过程中，局部变量会在堆或栈中存储它们的值，当函数执行结束后，这些局部变量不再被使用，它们所占有的空间就会被释放；</p>
<p>不过，当局部变量被外部函数使用时，其中一种情况就是闭包，在函数执行结束后，函数外部的变量依然指向函数内部的局部变量，此时局部变量依然在被使用，所以不会回收。</p>
<p><strong>垃圾回收的方式</strong>：</p>
<p>浏览器通常使用的垃圾回收方法有两种：标记清除，引用计数。</p>
<p><strong>标记清除</strong>：</p>
<ul>
<li>标记清除是浏览器常见的垃圾回收方式，当变量进入执行环境时，就标记这个变量“进入环境”，被标记为“进入环境”的变量是不能被回收的，因为他们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。</li>
<li>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。</li>
</ul>
<p><strong>引用计数</strong></p>
<ul>
<li>另外一种垃圾回收机制就是引用计数，这个用的相对较少。引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变为0时，说明这个变量已经没有价值，因此，在在机回收期下次再运行时，这个变量所占有的内存空间就会被释放出来。</li>
<li>这种方法会引起循环引用的问题：例如： obj1和 obj2通过属性进行相互引用，两个对象的引用次数都是2。当使用循环计数时，由于函数执行完后，两个对象都离开作用域，函数执行结束，obj1和 obj2还将会继续存在，因此它们的引用次数永远不会是0，就会引起循环引用。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> obj1 = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> obj2 = &#123;&#125;;</span><br><span class="line">    obj1.<span class="property">a</span> = obj2; <span class="comment">// obj1 引用 obj2</span></span><br><span class="line">    obj2.<span class="property">a</span> = obj1; <span class="comment">// obj2 引用 obj1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//手动释放内存</span></span><br><span class="line">obj1.<span class="property">a</span> =  <span class="literal">null</span></span><br><span class="line">obj2.<span class="property">a</span> =  <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p><strong>减少垃圾回收</strong>:</p>
<p>虽然浏览器可以进行垃圾自动回收，但是当代码比较复杂时，垃圾回收所带来的代价比较大，所以应该尽量减少垃圾回收。</p>
<ul>
<li><strong>对数组进行优化：</strong>在清空一个数组时，最简单的方法就是给其赋值为[ ]，但是与此同时会创建一个新的空对象，可以将数组的长度设置为0，以此来达到清空数组的目的。</li>
<li><strong>对object进行优化：</strong>对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收。</li>
<li><strong>对函数进行优化：</strong>在循环中的函数表达式，如果可以复用，尽量放在函数的外面。</li>
</ul>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>以下四种情况会造成内存的泄漏：</p>
<ul>
<li><strong>意外的全局变量：</strong>由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</li>
<li><strong>被遗忘的计时器或回调函数：</strong>设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li>
<li><strong>脱离 DOM 的引用：</strong>获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。</li>
<li><strong>闭包：</strong>不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li>
</ul>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="0-1-0-2-x3D-x3D-0-3如何让其相等"><a href="#0-1-0-2-x3D-x3D-0-3如何让其相等" class="headerlink" title="0.1+0.2 !&#x3D;&#x3D;  0.3如何让其相等"></a>0.1+0.2 !&#x3D;&#x3D;  0.3如何让其相等</h2><p>精度丢失问题</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Number.EPSILON</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">numberepsilon</span>(<span class="params">arg1, arg2</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">abs</span>(arg1 - arg2) &lt; <span class="title class_">Number</span>.<span class="property">EPSILON</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">numberepsilon</span>(<span class="number">0.1</span>+<span class="number">0.2</span>, <span class="number">0.3</span>)) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>





<p><em><strong>附录：</strong></em></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://zhuanlan.zhihu.com/p/617704546">JavaScript代码的三种引入方式【操作演示】 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.w3cschool.cn/web_interview/web_interview-u8jo3pu4.html"> JavaScript篇_w3cschool</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.bookstack.cn/read/es6-3rd/spilt.1.docs-simd.md">33. SIMD - 概述 - 《阮一峰 ECMAScript 6 (ES6) 标准入门教程 第三版》 - 书栈网 · BookStack</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.jianshu.com/p/23fad3814398">JavaScript事件循环机制解析 - 简书 (jianshu.com)</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://juejin.cn/post/7061987842473345061#heading-2">JS 常用的六种设计模式介绍 - 掘金 (juejin.cn)</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://juejin.cn/post/6844904032826294286">JavaScript设计模式es6（23种) - 掘金 (juejin.cn)</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://juejin.cn/post/7052148234097000462#heading-0">10分钟掌握JavaScript设计模式 - 掘金 (juejin.cn)</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://lemonxu.eu.org">Lemonxu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lemonxu.eu.org/2023/06/25/javascript/">https://lemonxu.eu.org/2023/06/25/javascript/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lemonxu.eu.org" target="_blank">Lemonxu's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaScript-%E5%9F%BA%E7%A1%80/">JavaScript, 基础</a></div><div class="post_share"><div class="social-share" data-image="/images/bg/646.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/07/17/web-rendering/" title="关于前端渲染方式以及性能"><img class="cover" src="/images/bg/641.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">关于前端渲染方式以及性能</div></div></a></div><div class="next-post pull-right"><a href="/2023/06/16/CSS/CSS/" title="CSS"><img class="cover" src="/images/bg/641.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">CSS</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/user.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lemonxu</div><div class="author-info__description">一个以前端开发为主的博客，一个专注前端的开发人员</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/Lemonxu"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Lemonxu" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:yunfeng7@foxmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JS%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">JS基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">引入方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-x2F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-x2F-BOM-x2F-DOM"><span class="toc-number">1.3.</span> <span class="toc-text">面向对象&#x2F;设计模式&#x2F;BOM&#x2F;DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.1.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">创建对象方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">对象的继承方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.2.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%9E%8B"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">创建型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%9E%8B"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">结构型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E4%B8%BA%E5%9E%8B"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">行为型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BOM"><span class="toc-number">1.3.3.</span> <span class="toc-text">BOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM"><span class="toc-number">1.3.4.</span> <span class="toc-text">DOM</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%A7%8D%E7%B1%BB%EF%BC%888%E7%A7%8D%EF%BC%89"><span class="toc-number">1.4.0.1.</span> <span class="toc-text">数据类型种类（8种）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95%EF%BC%884%E7%A7%8D%EF%BC%89"><span class="toc-number">1.4.0.2.</span> <span class="toc-text">数据类型检测方法（4种）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84%E6%96%B9%E5%BC%8F%EF%BC%885%E7%A7%8D%EF%BC%89"><span class="toc-number">1.4.0.3.</span> <span class="toc-text">判断数组方式（5种）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95%EF%BC%8810%E7%A7%8D%EF%BC%89"><span class="toc-number">1.4.0.4.</span> <span class="toc-text">数组的遍历方法（10种）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%EF%BC%88%E6%93%8D%E4%BD%9C%E7%AC%A6new-x2F-%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%EF%BC%89"><span class="toc-number">1.5.</span> <span class="toc-text">基础（操作符new&#x2F;隐式转换）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99"><span class="toc-number">1.5.1.</span> <span class="toc-text">隐式转换规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6new"><span class="toc-number">1.5.2.</span> <span class="toc-text">操作符new</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.5.3.</span> <span class="toc-text">内置对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.5.4.</span> <span class="toc-text">位运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81"><span class="toc-number">1.5.5.</span> <span class="toc-text">原码、补码、反码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F-x2F-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87-x2F-%E9%97%AD%E5%8C%85"><span class="toc-number">1.6.</span> <span class="toc-text">作用域&#x2F;执行上下文&#x2F;闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">1.6.1.</span> <span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F-x2F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-number">1.6.2.</span> <span class="toc-text">作用域&#x2F;作用域链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.6.3.</span> <span class="toc-text">对执行上下文的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this-x2F-call-x2F-apply-x2F-bind"><span class="toc-number">1.6.4.</span> <span class="toc-text">this&#x2F;call&#x2F;apply&#x2F;bind</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9this%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">对this对象的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#call-%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">call 函数的实现步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#apply-%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.6.4.3.</span> <span class="toc-text">apply 函数的实现步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bind-%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.6.4.4.</span> <span class="toc-text">bind 函数的实现步骤</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B-x2F-%E5%8E%9F%E5%9E%8B%E9%93%BE-x2F-%E7%BB%A7%E6%89%BF"><span class="toc-number">1.7.</span> <span class="toc-text">原型&#x2F;原型链&#x2F;继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.8.</span> <span class="toc-text">事件循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B-x2F-Promise-x2F-async%E5%92%8Cawait-x2F-%E5%B9%B6%E5%8F%91-x2F-%E5%B9%B6%E8%A1%8C"><span class="toc-number">1.9.</span> <span class="toc-text">异步编程&#x2F;Promise&#x2F;async和await&#x2F;并发&#x2F;并行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">1.9.1.</span> <span class="toc-text">JavaScript中的异步机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setTimeout%E3%80%81Promise%E3%80%81Async-x2F-Await-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.9.2.</span> <span class="toc-text">setTimeout、Promise、Async&#x2F;Await 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9Promise%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.9.3.</span> <span class="toc-text">对Promise的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.9.4.</span> <span class="toc-text">并发与并行的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Proxy"><span class="toc-number">1.10.</span> <span class="toc-text">Proxy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E5%8C%BA%E5%88%AB%EF%BC%89"><span class="toc-number">1.11.</span> <span class="toc-text">ES6新特性（常用方法区别）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ajax-x2F-fetch-x2F-axios-x2F-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.12.</span> <span class="toc-text">Ajax&#x2F;fetch&#x2F;axios&#x2F;网络协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Ajax"><span class="toc-number">1.12.1.</span> <span class="toc-text">Ajax</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fetch"><span class="toc-number">1.12.2.</span> <span class="toc-text">Fetch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Axios"><span class="toc-number">1.12.3.</span> <span class="toc-text">Axios</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">1.13.</span> <span class="toc-text">垃圾回收与内存泄漏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">1.13.1.</span> <span class="toc-text">浏览器的垃圾回收机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">1.13.2.</span> <span class="toc-text">内存泄漏</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">常见问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-1-0-2-x3D-x3D-0-3%E5%A6%82%E4%BD%95%E8%AE%A9%E5%85%B6%E7%9B%B8%E7%AD%89"><span class="toc-number">2.1.</span> <span class="toc-text">0.1+0.2 !&#x3D;&#x3D;  0.3如何让其相等</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/09/05/frontend-performance/" title="前端性能优化实战"><img src="/images/bg/649.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端性能优化实战"/></a><div class="content"><a class="title" href="/2023/09/05/frontend-performance/" title="前端性能优化实战">前端性能优化实战</a><time datetime="2023-09-05T18:41:52.000Z" title="发表于 2023-09-05 18:41:52">2023-09-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/17/web-rendering/" title="关于前端渲染方式以及性能"><img src="/images/bg/641.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="关于前端渲染方式以及性能"/></a><div class="content"><a class="title" href="/2023/07/17/web-rendering/" title="关于前端渲染方式以及性能">关于前端渲染方式以及性能</a><time datetime="2023-07-17T18:06:09.000Z" title="发表于 2023-07-17 18:06:09">2023-07-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/25/javascript/" title="javascript"><img src="/images/bg/646.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="javascript"/></a><div class="content"><a class="title" href="/2023/06/25/javascript/" title="javascript">javascript</a><time datetime="2023-06-25T17:39:57.000Z" title="发表于 2023-06-25 17:39:57">2023-06-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/16/CSS/CSS/" title="CSS"><img src="/images/bg/641.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS"/></a><div class="content"><a class="title" href="/2023/06/16/CSS/CSS/" title="CSS">CSS</a><time datetime="2023-06-16T11:57:58.000Z" title="发表于 2023-06-16 11:57:58">2023-06-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/31/responsive-html/responsive-html/" title="前端响应式网站设计"><img src="/images/bg/646.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端响应式网站设计"/></a><div class="content"><a class="title" href="/2023/05/31/responsive-html/responsive-html/" title="前端响应式网站设计">前端响应式网站设计</a><time datetime="2023-05-31T09:07:50.000Z" title="发表于 2023-05-31 09:07:50">2023-05-31</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By Lemonxu</div><div class="footer_custom_text">本博客由Lemonxu使用Hexo搭建，部分素材来自网络，如有侵权请联系删除</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  const disqus_config = function () {
    this.page.url = 'https://lemonxu.eu.org/2023/06/25/javascript/'
    this.page.identifier = '/2023/06/25/javascript/'
    this.page.title = 'javascript'
  }

  const disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  btf.addModeChange('disqus', disqusReset)

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Valine' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>